// Copyright (c) 2024 Seagate Technology LLC and/or its Affiliates
/*
Composable Fabric Manager Service OpenAPI

This API allows users to interact through the CFM Service with CXL Hosts and Memory Appliances. The main purpose of this interface is to allow the retrieval of information and the creation and mapping of memory from a Memory Appliance to a CXL host.

API version: 1.6.1
Generated by: OpenAPI Generator (https://openapi-generator.tech)
*/

package api

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/godbus/dbus/v5"
	"github.com/holoplot/go-avahi"
	"k8s.io/klog/v2"

	"cfm/pkg/common"
	"cfm/pkg/manager"
	"cfm/pkg/openapi"
)

const (
	MAX_COUNT_APPLIANCES = 32
	MAX_COUNT_BLADES     = 8
	MAX_COUNT_HOSTS      = 32
)

// cfm-service code is not currently designed for multiple, simultaneous asynchronous api calls.
// This mutex forces all calls into cfm-service to be synchronous (so, one-at-a-time)
// Initial implementation of this mutex created an order of magnitude faster response to webui updating.
// However, as the software matures, usage of this mutex may need to be re-evaluted.
var mu sync.Mutex

// CfmApiService is a service that implements the logic for the cfm-service.
// This service should implement the business logic for every endpoint for the DefaultAPI API.
// Include any external packages or services that will be required by this service.
type CfmApiService struct {
	Version string
}

// NewCfmApiService creates a default api service
func NewCfmApiService(version string) openapi.DefaultAPIServicer {
	return &CfmApiService{Version: version}
}

// AppliancesDeleteById -
func (cfm *CfmApiService) AppliancesDeleteById(ctx context.Context, applianceId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### AppliancesDeleteById: ", "applianceId", applianceId)

	var a openapi.Appliance

	appliance, err := manager.DeleteApplianceById(ctx, applianceId)
	if err != nil {
		a = openapi.Appliance{Id: applianceId}

	} else {

		a = openapi.Appliance{
			Id:        appliance.Id,
			IpAddress: "", // Unused (May need for POC4)
			Port:      0,  // Unused (May need for POC4)
			Status:    "", // Unused
			Blades: openapi.MemberItem{
				Uri: manager.GetCfmUriBlades(appliance.Id),
			},
			TotalMemoryAvailableMiB: -1, // Not Implemented
			TotalMemoryAllocatedMiB: -1, // Not Implemented
		}
	}

	return openapi.Response(http.StatusOK, a), nil
}

// AppliancesGet -
func (cfm *CfmApiService) AppliancesGet(ctx context.Context) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### AppliancesGet")

	// order returned uris by appliance id
	applianceIds := manager.GetAllApplianceIds()
	sort.Strings(applianceIds)

	appliances := manager.GetAppliances(ctx)

	response := openapi.Collection{
		MemberCount: int32(len(appliances)),
	}
	for _, id := range applianceIds {
		response.Members = append(response.Members, openapi.MemberItem{
			Uri: appliances[id].Uri,
		})
	}

	return openapi.Response(http.StatusOK, response), nil
}

// AppliancesGetById -
func (cfm *CfmApiService) AppliancesGetById(ctx context.Context, applianceId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### AppliancesGetById: ", "applianceId", applianceId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	totals, err := appliance.GetResourceTotals(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	a := openapi.Appliance{
		Id:        appliance.Id,
		IpAddress: "", // Unused
		Port:      0,  // Unused
		Status:    "", // Unused
		Blades: openapi.MemberItem{
			Uri: manager.GetCfmUriBlades(appliance.Id),
		},
		TotalMemoryAvailableMiB: totals.TotalMemoryAvailableMiB,
		TotalMemoryAllocatedMiB: totals.TotalMemoryAllocatedMiB,
	}

	return openapi.Response(http.StatusOK, a), nil
}

// AppliancesPost -
func (cfm *CfmApiService) AppliancesPost(ctx context.Context, credentials openapi.Credentials) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### AppliancesPost")

	appliances := manager.GetAppliances(ctx)
	if len(appliances) >= MAX_COUNT_APPLIANCES {
		err := common.RequestError{
			StatusCode: common.StatusAppliancesExceedMaximum,
			Err:        fmt.Errorf("cfm-service at maximum appliance capacity (%d)", MAX_COUNT_APPLIANCES),
		}
		return formatErrorResp(ctx, &err)
	}

	appliance, err := manager.AddAppliance(ctx, &credentials)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	a := openapi.Appliance{
		Id:        appliance.Id,
		IpAddress: "", // Unused
		Port:      0,  // Unused
		Status:    "", // Unused
		Blades: openapi.MemberItem{
			Uri: manager.GetCfmUriBlades(appliance.Id),
		},
		TotalMemoryAvailableMiB: 0, // Currently, new appliances have no initial knowledge of their blades
		TotalMemoryAllocatedMiB: 0, // Currently, new appliances have no initial knowledge of their blades
	}

	return openapi.Response(http.StatusCreated, a), nil
}

// AppliancesUpdateById -
func (cfm *CfmApiService) AppliancesUpdateById(ctx context.Context, applianceId string, newApplianceId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### AppliancesUpdateById: ", "applianceId", applianceId)

	// Make sure the newApplianceId doesn't exist
	_, exist := manager.GetApplianceById(ctx, newApplianceId)
	if exist == nil {
		err := common.RequestError{
			StatusCode: common.StatusApplianceIdDuplicate,
			Err:        fmt.Errorf("the new name (%s) already exists", newApplianceId),
		}
		return formatErrorResp(ctx, &err)
	}

	// Make sure the appliance exists
	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	//Rename the appliance with the new id
	newAppliance, err := manager.RenameAppliance(ctx, appliance, newApplianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	a := openapi.Appliance{
		Id:        newAppliance.Id,
		IpAddress: "", // Unused
		Port:      0,  // Unused
		Status:    "", // Unused
		Blades: openapi.MemberItem{
			Uri: manager.GetCfmUriBlades(newAppliance.Id),
		},
		TotalMemoryAvailableMiB: 0,
		TotalMemoryAllocatedMiB: 0,
	}

	return openapi.Response(http.StatusOK, a), nil
}

// AppliancesResync -
func (cfm *CfmApiService) AppliancesResyncById(ctx context.Context, applianceId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### AppliancesResyncById: ", "applianceId", applianceId)

	appliance, err := manager.ResyncApplianceById(ctx, applianceId)

	if err != nil {
		if appliance != nil {
			return openapi.Response(http.StatusPartialContent, appliance), nil
		} else {
			return formatErrorResp(ctx, err.(*common.RequestError))
		}
	}

	totals, err := appliance.GetResourceTotals(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	a := openapi.Appliance{
		Id:        appliance.Id,
		IpAddress: "", // Unused
		Port:      0,  // Unused
		Status:    "", // Unused
		Blades: openapi.MemberItem{
			Uri: manager.GetCfmUriBlades(appliance.Id),
		},
		TotalMemoryAvailableMiB: totals.TotalMemoryAvailableMiB,
		TotalMemoryAllocatedMiB: totals.TotalMemoryAllocatedMiB,
	}

	return openapi.Response(http.StatusOK, a), nil
}

// BladesAssignMemoryById - Assign\Unassign the specified memory region (iedntified via memoryId) to\from the specified portId.  Assign\Unassigned is set in request's Operation parameter.
func (cfm *CfmApiService) BladesAssignMemoryById(ctx context.Context, applianceId string, bladeId string, memoryId string, assignMemoryRequest openapi.AssignMemoryRequest) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesAssignMemoryById: ", "applianceId", applianceId, "bladeId", bladeId, "memoryId", memoryId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	r := manager.RequestAssignMemory{
		MemoryId:  memoryId,
		PortId:    assignMemoryRequest.Port,
		Operation: assignMemoryRequest.Operation,
	}

	memory, err := blade.AssignMemory(ctx, &r)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	return openapi.Response(http.StatusOK, memory), nil
}

// BladesComposeMemory - Using available blade resources, provision a new blade memory region and assign it to the designated port [Note: provision + assign = compose]. If composeMemoryRequest.Port == nil, provision only.
func (cfm *CfmApiService) BladesComposeMemory(ctx context.Context, applianceId string, bladeId string, composeMemoryRequest openapi.ComposeMemoryRequest) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesComposeMemory: ", "applianceId", applianceId, "bladeId", bladeId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	r := manager.RequestComposeMemory{
		PortId:  composeMemoryRequest.Port,
		SizeMib: composeMemoryRequest.MemorySizeMiB,
		Qos:     composeMemoryRequest.QoS,
	}

	memory, err := blade.ComposeMemory(ctx, &r)
	if err != nil {
		if memory != nil {
			return openapi.Response(http.StatusPartialContent, memory), nil
		} else {
			return formatErrorResp(ctx, err.(*common.RequestError))
		}
	}

	return openapi.Response(http.StatusCreated, memory), nil
}

// BladesComposeMemoryByResource -
func (cfm *CfmApiService) BladesComposeMemoryByResource(ctx context.Context, applianceId string, bladeId string, composeMemoryByResourceRequest openapi.ComposeMemoryByResourceRequest) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesComposeMemoryByResource: ", "applianceId", applianceId, "bladeId", bladeId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.ComposeMemoryByResource(ctx, composeMemoryByResourceRequest.Port, composeMemoryByResourceRequest.MemoryResources)
	if err != nil {
		if memory != nil {
			return openapi.Response(http.StatusPartialContent, memory), nil
		} else {
			return formatErrorResp(ctx, err.(*common.RequestError))
		}
	}

	return openapi.Response(http.StatusCreated, memory), nil
}

// BladesDeleteById - As long as the appliance id is valid, guarenteed blade deletion from service
func (cfm *CfmApiService) BladesDeleteById(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesDeleteById: ", "applianceId", applianceId, "bladeId", bladeId)

	var b openapi.Blade

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.DeleteBladeById(ctx, bladeId)
	if err != nil {
		b = openapi.Blade{Id: bladeId}

	} else {

		b = openapi.Blade{
			Id:        blade.Id,
			IpAddress: blade.GetNetIp(),
			Port:      int32(blade.GetNetPort()),
			Status:    string(blade.Status),
			Ports: openapi.MemberItem{
				Uri: manager.GetCfmUriBladePorts(appliance.Id, blade.Id),
			},
			Resources: openapi.MemberItem{
				Uri: manager.GetCfmUriBladeResources(appliance.Id, blade.Id),
			},
			Memory: openapi.MemberItem{
				Uri: manager.GetCfmUriBladeMemory(appliance.Id, blade.Id),
			},
			TotalMemoryAvailableMiB: -1, // Not Implemented
			TotalMemoryAllocatedMiB: -1, // Not Implemented
		}
	}

	return openapi.Response(http.StatusOK, b), nil
}

// BladesFreeMemoryById -
func (cfm *CfmApiService) BladesFreeMemoryById(ctx context.Context, applianceId string, bladeId string, memoryId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesFreeMemoryById: ", "applianceId", applianceId, "bladeId", bladeId, "memoryId", memoryId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.FreeMemoryById(ctx, memoryId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	return openapi.Response(http.StatusOK, memory), nil
}

// BladesGet -
func (cfm *CfmApiService) BladesGet(ctx context.Context, applianceId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesGet: ", "applianceId", applianceId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by blade id
	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)

	blades := appliance.GetBlades(ctx)

	response := openapi.Collection{
		MemberCount: int32(len(blades)),
	}
	for _, id := range bladeIds {
		response.Members = append(response.Members, openapi.MemberItem{
			Uri: blades[id].Uri,
		})
	}

	return openapi.Response(http.StatusOK, response), nil
}

// BladesGetById -
func (cfm *CfmApiService) BladesGetById(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesGetById: ", "applianceId", applianceId, "bladeId", bladeId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	totals, err := blade.GetResourceTotals(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	b := openapi.Blade{
		Id:        blade.Id,
		IpAddress: blade.GetNetIp(),
		Port:      int32(blade.GetNetPort()),
		Status:    string(blade.Status),
		Ports: openapi.MemberItem{
			Uri: manager.GetCfmUriBladePorts(appliance.Id, blade.Id),
		},
		Resources: openapi.MemberItem{
			Uri: manager.GetCfmUriBladeResources(appliance.Id, blade.Id),
		},
		Memory: openapi.MemberItem{
			Uri: manager.GetCfmUriBladeMemory(appliance.Id, blade.Id),
		},
		TotalMemoryAvailableMiB: totals.TotalMemoryAvailableMiB,
		TotalMemoryAllocatedMiB: totals.TotalMemoryAllocatedMiB,
	}

	return openapi.Response(http.StatusOK, b), nil
}

// BladesGetMemoryStatus - Get blades memory chunk status
func (cfm *CfmApiService) BladesGetMemoryStatus(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	// TODO - update BladesGetMemoryStatus with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, []BladesMemoryStatus{}) or use other options such as http.Ok ...
	// return Response(200, []BladesMemoryStatus{}), nil

	// TODO: Uncomment the next line to return response Response(404, StatusMessage{}) or use other options such as http.Ok ...
	// return Response(404, StatusMessage{}), nil

	// TODO: Uncomment the next line to return response Response(500, StatusMessage{}) or use other options such as http.Ok ...
	// return Response(500, StatusMessage{}), nil

	return openapi.Response(http.StatusNotImplemented, nil), errors.New("BladesGetMemoryStatus method not implemented")
}

// BladesGetMemory -
func (cfm *CfmApiService) BladesGetMemory(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesGetMemory: ", "applianceId", applianceId, "bladeId", bladeId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by memory id
	memoryIds := blade.GetAllMemoryIds(ctx)
	sort.Strings(memoryIds)

	memory := blade.GetMemory(ctx)

	response := openapi.Collection{
		MemberCount: int32(len(memory)),
	}
	for _, id := range memoryIds {
		response.Members = append(response.Members, openapi.MemberItem{
			Uri: memory[id].Uri,
		})
	}

	return openapi.Response(http.StatusOK, response), nil
}

// BladesGetMemoryById -
func (cfm *CfmApiService) BladesGetMemoryById(ctx context.Context, applianceId string, bladeId string, memoryId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesGetMemoryById: ", "applianceId", applianceId, "bladeId", bladeId, "memoryId", memoryId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.GetMemoryById(ctx, memoryId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	if memory != nil {
		details, err := memory.GetDetails(ctx)
		if err != nil {
			return formatErrorResp(ctx, err.(*common.RequestError))
		}

		return openapi.Response(http.StatusOK, details), nil

	} else {
		return openapi.Response(http.StatusOK, openapi.MemoryRegion{}), nil
	}
}

// BladesGetPortById -
func (cfm *CfmApiService) BladesGetPortById(ctx context.Context, applianceId string, bladeId string, portId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesGetPortById: ", "applianceId", applianceId, "bladeId", bladeId, "portId", portId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	port, err := blade.GetPortById(ctx, portId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	if port != nil {
		details, err := port.GetDetails(ctx)
		if err != nil {
			return formatErrorResp(ctx, err.(*common.RequestError))
		}

		return openapi.Response(http.StatusOK, details), nil

	} else {
		return openapi.Response(http.StatusOK, openapi.PortInformation{}), nil
	}
}

// BladesGetPortStatus - Get blades port status
func (cfm *CfmApiService) BladesGetPortStatus(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	// TODO - update BladesGetPortStatus with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, []BladesPortStatus{}) or use other options such as http.Ok ...
	// return Response(200, []BladesPortStatus{}), nil

	// TODO: Uncomment the next line to return response Response(404, StatusMessage{}) or use other options such as http.Ok ...
	// return Response(404, StatusMessage{}), nil

	// TODO: Uncomment the next line to return response Response(500, StatusMessage{}) or use other options such as http.Ok ...
	// return Response(500, StatusMessage{}), nil

	return openapi.Response(http.StatusNotImplemented, nil), errors.New("BladesGetPortStatus method not implemented")
}

// BladesGetPorts -
func (cfm *CfmApiService) BladesGetPorts(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesGetPorts: ", "applianceId", applianceId, "bladeId", bladeId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by port id
	portIds := blade.GetAllPortIds(ctx)
	sort.Strings(portIds)

	ports := blade.GetPorts(ctx)

	response := openapi.Collection{
		MemberCount: int32(len(ports)),
	}
	for _, id := range portIds {
		response.Members = append(response.Members, openapi.MemberItem{
			Uri: ports[id].Uri,
		})
	}

	return openapi.Response(http.StatusOK, response), nil
}

// BladesUpdateById -
func (cfm *CfmApiService) BladesUpdateById(ctx context.Context, applianceId string, bladeId string, newBladeId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesUpdateById: ", "applianceId", applianceId, "bladeId", bladeId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// Make sure the bladeId exists
	// Get the blade information from the manager level and is used for renaming
	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// Make sure the newBladeId doesn't exist
	existBladeIds := appliance.GetAllBladeIds()
	for _, id := range existBladeIds {
		if newBladeId == id {
			err := common.RequestError{
				StatusCode: common.StatusBladeIdDuplicate,
				Err:        fmt.Errorf("the new name (%s) already exists", newBladeId),
			}
			return formatErrorResp(ctx, &err)
		}
	}

	//Rename the appliance with the new id
	newBlade, err := manager.RenameBlade(ctx, appliance, blade, newBladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	totals, err := newBlade.GetResourceTotals(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	b := openapi.Blade{
		Id:        newBlade.Id,
		IpAddress: newBlade.GetNetIp(),
		Port:      int32(newBlade.GetNetPort()),
		Status:    string(newBlade.Status),
		Ports: openapi.MemberItem{
			Uri: manager.GetCfmUriBladePorts(appliance.Id, newBlade.Id),
		},
		Resources: openapi.MemberItem{
			Uri: manager.GetCfmUriBladeResources(appliance.Id, newBlade.Id),
		},
		Memory: openapi.MemberItem{
			Uri: manager.GetCfmUriBladeMemory(appliance.Id, newBlade.Id),
		},
		TotalMemoryAvailableMiB: totals.TotalMemoryAvailableMiB,
		TotalMemoryAllocatedMiB: totals.TotalMemoryAllocatedMiB,
	}

	return openapi.Response(http.StatusOK, b), nil
}

// BladesGetResourceById -
func (cfm *CfmApiService) BladesGetResourceById(ctx context.Context, applianceId string, bladeId string, resourceId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesGetResourceById: ", "applianceId", applianceId, "bladeId", bladeId, "resourceId", resourceId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	resource, err := blade.GetResourceById(ctx, resourceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	if resource != nil {
		details, err := resource.GetDetails(ctx)
		if err != nil {
			return formatErrorResp(ctx, err.(*common.RequestError))
		}

		return openapi.Response(http.StatusOK, details), nil

	} else {
		return openapi.Response(http.StatusOK, openapi.MemoryResourceBlock{}), nil
	}
}

// BladesGetResourceStatus - Get blades memory resource status
func (cfm *CfmApiService) BladesGetResourceStatus(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesGetResourceStatus: ", "applianceId", applianceId, "bladeId", bladeId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	collection, err := blade.GetResourceStatusesBackend(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	return openapi.Response(http.StatusOK, collection), nil
}

// BladesGetResources -
func (cfm *CfmApiService) BladesGetResources(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesGetResources: ", "applianceId", applianceId, "bladeId", bladeId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by resourse id
	resourceIds := blade.GetAllResourceIds(ctx)
	sort.Strings(resourceIds)

	resources := blade.GetResources(ctx)

	response := openapi.Collection{
		MemberCount: int32(len(resources)),
	}
	for _, id := range resourceIds {
		response.Members = append(response.Members, openapi.MemberItem{
			Uri: resources[id].Uri,
		})
	}

	return openapi.Response(http.StatusOK, response), nil
}

// BladesGetStatus - Get blade status
func (cfm *CfmApiService) BladesGetStatus(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	// TODO - update BladesGetStatus with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, BladesStatus{}) or use other options such as http.Ok ...
	// return Response(200, BladesStatus{}), nil

	// TODO: Uncomment the next line to return response Response(404, StatusMessage{}) or use other options such as http.Ok ...
	// return Response(404, StatusMessage{}), nil

	// TODO: Uncomment the next line to return response Response(500, StatusMessage{}) or use other options such as http.Ok ...
	// return Response(500, StatusMessage{}), nil

	return openapi.Response(http.StatusNotImplemented, nil), errors.New("BladesGetStatus method not implemented")
}

// BladesPost -
func (cfm *CfmApiService) BladesPost(ctx context.Context, applianceId string, credentials openapi.Credentials) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesPost: ", "applianceId", applianceId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	if len(appliance.Blades) == MAX_COUNT_BLADES {
		err := common.RequestError{
			StatusCode: common.StatusBladesExceedMaximum,
			Err:        fmt.Errorf("cfm-service at maximum blade capacity (%d) for this appliance (%s)", MAX_COUNT_BLADES, applianceId),
		}
		return formatErrorResp(ctx, &err)
	}

	blade, err := appliance.AddBlade(ctx, &credentials)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	totals, err := blade.GetResourceTotals(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	b := openapi.Blade{
		Id:        blade.Id,
		IpAddress: blade.GetNetIp(),
		Port:      int32(blade.GetNetPort()),
		Status:    string(blade.Status),
		Ports: openapi.MemberItem{
			Uri: manager.GetCfmUriBladePorts(appliance.Id, blade.Id),
		},
		Resources: openapi.MemberItem{
			Uri: manager.GetCfmUriBladeResources(appliance.Id, blade.Id),
		},
		Memory: openapi.MemberItem{
			Uri: manager.GetCfmUriBladeMemory(appliance.Id, blade.Id),
		},
		TotalMemoryAvailableMiB: totals.TotalMemoryAvailableMiB,
		TotalMemoryAllocatedMiB: totals.TotalMemoryAllocatedMiB,
	}

	return openapi.Response(http.StatusCreated, b), nil
}

// BladesResync -
func (cfm *CfmApiService) BladesResyncById(ctx context.Context, applianceId string, bladeId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### BladesResyncById: ", "applianceId", applianceId, "bladeId", bladeId)

	appliance, err := manager.GetApplianceById(ctx, applianceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.ResyncBladeById(ctx, bladeId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	totals, err := blade.GetResourceTotals(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	b := openapi.Blade{
		Id:        blade.Id,
		IpAddress: blade.GetNetIp(),
		Port:      int32(blade.GetNetPort()),
		Status:    string(blade.Status),
		Ports: openapi.MemberItem{
			Uri: manager.GetCfmUriBladePorts(appliance.Id, blade.Id),
		},
		Resources: openapi.MemberItem{
			Uri: manager.GetCfmUriBladeResources(appliance.Id, blade.Id),
		},
		Memory: openapi.MemberItem{
			Uri: manager.GetCfmUriBladeMemory(appliance.Id, blade.Id),
		},
		TotalMemoryAvailableMiB: totals.TotalMemoryAvailableMiB,
		TotalMemoryAllocatedMiB: totals.TotalMemoryAllocatedMiB,
	}

	return openapi.Response(http.StatusOK, b), nil
}

// HostGetMemory -
func (cfm *CfmApiService) HostGetMemory(ctx context.Context, hostId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostGetMemory: ", "hostId", hostId)

	host, err := manager.GetHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by memory id
	memoryIds := host.GetAllMemoryIds(ctx)
	sort.Strings(memoryIds)

	memory := host.GetMemory(ctx)

	response := openapi.Collection{
		MemberCount: int32(len(memory)),
	}
	for _, id := range memoryIds {
		response.Members = append(response.Members, openapi.MemberItem{
			Uri: memory[id].Uri,
		})
	}

	return openapi.Response(http.StatusOK, response), nil
}

// HostsComposeMemory -
func (cfm *CfmApiService) HostsComposeMemory(ctx context.Context, hostId string, composeMemoryRequest openapi.ComposeMemoryRequest) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsComposeMemory: ", "hostId", hostId)

	host, err := manager.GetHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	r := manager.RequestComposeMemory{
		PortId:  composeMemoryRequest.Port,
		SizeMib: composeMemoryRequest.MemorySizeMiB,
		Qos:     composeMemoryRequest.QoS,
	}

	memory, err := host.ComposeMemory(ctx, &r)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	return openapi.Response(http.StatusCreated, memory), nil
}

// HostsDeleteById - Guarenteed host deletion from service.
func (cfm *CfmApiService) HostsDeleteById(ctx context.Context, hostId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsDeleteById: ", "hostId", hostId)

	var h openapi.Host

	host, err := manager.DeleteHostById(ctx, hostId)
	if err != nil && host == nil {
		h = openapi.Host{Id: hostId}

	} else {

		h = openapi.Host{
			Id:        host.Id,
			IpAddress: host.GetNetIp(),
			Port:      int32(host.GetNetPort()),
			Status:    string(host.Status),
			Ports: openapi.MemberItem{
				Uri: manager.GetCfmUriHostPorts(host.Id),
			},
			Memory: openapi.MemberItem{
				Uri: manager.GetCfmUriHostMemory(host.Id),
			},
			MemoryDevices: openapi.MemberItem{
				Uri: manager.GetCfmUriHostMemoryDevices(host.Id),
			},
			LocalMemoryMiB:  -1, // Not implemented
			RemoteMemoryMiB: -1, // Not implemented
		}
	}

	return openapi.Response(http.StatusOK, h), nil
}

// HostsFreeMemoryById -
func (cfm *CfmApiService) HostsFreeMemoryById(ctx context.Context, hostId string, memoryId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsFreeMemoryById: ", "hostId", hostId, "memoryId", memoryId)

	host, err := manager.GetHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := host.FreeMemoryById(ctx, memoryId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	return openapi.Response(http.StatusOK, memory), nil
}

// HostsGet - Get CXL Host information.
func (cfm *CfmApiService) HostsGet(ctx context.Context) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsGet")

	// order returned uris by host id
	hostIds := manager.GetAllHostIds()
	sort.Strings(hostIds)

	hosts := manager.GetHosts(ctx)

	response := openapi.Collection{
		MemberCount: int32(len(hosts)),
	}
	for _, id := range hostIds {
		response.Members = append(response.Members, openapi.MemberItem{
			Uri: hosts[id].Uri,
		})
	}

	return openapi.Response(http.StatusOK, response), nil
}

// HostsGetById - Get information for a single CXL Host.
func (cfm *CfmApiService) HostsGetById(ctx context.Context, hostId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsGetById: ", "hostId", hostId)

	host, err := manager.GetHostById(ctx, hostId)
	if err != nil || host == nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	totals, err := host.GetMemoryTotals(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	h := openapi.Host{
		Id:        host.Id,
		IpAddress: host.GetNetIp(),
		Port:      int32(host.GetNetPort()),
		Status:    string(host.Status),
		Ports: openapi.MemberItem{
			Uri: manager.GetCfmUriHostPorts(host.Id),
		},
		MemoryDevices: openapi.MemberItem{
			Uri: manager.GetCfmUriHostMemoryDevices(host.Id),
		},
		Memory: openapi.MemberItem{
			Uri: manager.GetCfmUriHostMemory(host.Id),
		},
		LocalMemoryMiB:  totals.LocalMemoryMib,
		RemoteMemoryMiB: totals.RemoteMemoryMib,
	}

	return openapi.Response(http.StatusOK, h), nil
}

// HostsGetMemoryById -
func (cfm *CfmApiService) HostsGetMemoryById(ctx context.Context, hostId string, memoryId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsGetMemoryById: ", "hostId", hostId, "memoryId", memoryId)

	host, err := manager.GetHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := host.GetMemoryById(ctx, memoryId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memory.GetDetails(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	return openapi.Response(http.StatusOK, details), nil
}

// HostsGetMemoryDeviceById -
func (cfm *CfmApiService) HostsGetMemoryDeviceById(ctx context.Context, hostId string, memorydeviceId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsGetMemoryDeviceById: ", "hostId", hostId, "memorydeviceId", memorydeviceId)

	host, err := manager.GetHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	memdev, err := host.GetMemoryDeviceById(ctx, memorydeviceId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memdev.GetDetails(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	return openapi.Response(http.StatusOK, details), nil
}

// HostsGetMemoryDevices -
func (cfm *CfmApiService) HostsGetMemoryDevices(ctx context.Context, hostId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsGetMemoryDevices: ", "hostId", hostId)

	host, err := manager.GetHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by memory device id
	memdevIds := host.GetAllMemoryDeviceIds(ctx)
	sort.Strings(memdevIds)

	memdevs := host.GetMemoryDevices(ctx)

	response := openapi.Collection{
		MemberCount: int32(len(memdevs)),
	}
	for _, id := range memdevIds {
		response.Members = append(response.Members, openapi.MemberItem{
			Uri: memdevs[id].Uri,
		})
	}

	return openapi.Response(http.StatusOK, response), nil
}

// HostsGetPortById -
func (cfm *CfmApiService) HostsGetPortById(ctx context.Context, hostId string, portId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsGetPortById: ", "hostId", hostId, "portId", portId)

	host, err := manager.GetHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	port, err := host.GetPortById(ctx, portId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := port.GetDetails(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	return openapi.Response(http.StatusOK, details), nil
}

// HostsGetPorts -
func (cfm *CfmApiService) HostsGetPorts(ctx context.Context, hostId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsGetPorts: ", "hostId", hostId)

	host, err := manager.GetHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by port id
	portIds := host.GetAllPortIds(ctx)
	sort.Strings(portIds)

	ports := host.GetPorts(ctx)

	response := openapi.Collection{
		MemberCount: int32(len(ports)),
	}
	for _, id := range portIds {
		response.Members = append(response.Members, openapi.MemberItem{
			Uri: ports[id].Uri,
		})
	}

	return openapi.Response(http.StatusOK, response), nil
}

// HostsPost - Add a CXL host to be managed by CFM.
func (cfm *CfmApiService) HostsPost(ctx context.Context, credentials openapi.Credentials) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsPost")

	hosts := manager.GetHosts(ctx)
	if len(hosts) >= MAX_COUNT_HOSTS {
		err := common.RequestError{
			StatusCode: common.StatusHostsExceedMaximum,
			Err:        fmt.Errorf("cfm-service at maximum host capacity (%d)", MAX_COUNT_HOSTS),
		}
		return formatErrorResp(ctx, &err)
	}

	host, err := manager.AddHost(ctx, &credentials)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	h := openapi.Host{
		Id:        host.Id,
		IpAddress: host.GetNetIp(),
		Port:      int32(host.GetNetPort()),
		Status:    string(host.Status),
		Ports: openapi.MemberItem{
			Uri: manager.GetCfmUriHostPorts(host.Id),
		},
		Memory: openapi.MemberItem{
			Uri: manager.GetCfmUriHostMemory(host.Id),
		},
		MemoryDevices: openapi.MemberItem{
			Uri: manager.GetCfmUriHostMemoryDevices(host.Id),
		},
		LocalMemoryMiB:  -1, // Not implemented
		RemoteMemoryMiB: -1, // Not implemented
	}

	return openapi.Response(http.StatusCreated, h), nil
}

// HostsUpdateById -
func (cfm *CfmApiService) HostsUpdateById(ctx context.Context, hostId string, newHostId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsUpdateById: ", "hostId", hostId)

	// Make sure the hostId exists
	// Get the host information from the manager level and is used for renaming
	host, err := manager.GetHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	// Make sure the newHostId doesn't exist
	_, exist := manager.GetHostById(ctx, newHostId)
	if exist == nil {
		err := common.RequestError{
			StatusCode: common.StatusHostIdDuplicate,
			Err:        fmt.Errorf("the new name (%s) already exists", newHostId),
		}
		return formatErrorResp(ctx, &err)
	}

	//Rename the cxl host with the new id
	newHost, err := manager.RenameHost(ctx, host, newHostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	totals, err := newHost.GetMemoryTotals(ctx)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	h := openapi.Host{
		Id:        newHost.Id,
		IpAddress: newHost.GetNetIp(),
		Port:      int32(newHost.GetNetPort()),
		Status:    string(newHost.Status),
		Ports: openapi.MemberItem{
			Uri: manager.GetCfmUriHostPorts(newHost.Id),
		},
		Memory: openapi.MemberItem{
			Uri: manager.GetCfmUriHostMemory(newHost.Id),
		},
		MemoryDevices: openapi.MemberItem{
			Uri: manager.GetCfmUriHostMemoryDevices(newHost.Id),
		},
		LocalMemoryMiB:  totals.LocalMemoryMib,
		RemoteMemoryMiB: totals.RemoteMemoryMib,
	}

	return openapi.Response(http.StatusOK, h), nil
}

// HostsResync -
func (cfm *CfmApiService) HostsResyncById(ctx context.Context, hostId string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### HostsResyncById: ", "hostId", hostId)

	host, err := manager.ResyncHostById(ctx, hostId)
	if err != nil {
		return formatErrorResp(ctx, err.(*common.RequestError))
	}

	h := openapi.Host{
		Id:        host.Id,
		IpAddress: host.GetNetIp(),
		Port:      int32(host.GetNetPort()),
		Status:    string(host.Status),
		Ports: openapi.MemberItem{
			Uri: manager.GetCfmUriHostPorts(host.Id),
		},
		Memory: openapi.MemberItem{
			Uri: manager.GetCfmUriHostMemory(host.Id),
		},
		MemoryDevices: openapi.MemberItem{
			Uri: manager.GetCfmUriHostMemoryDevices(host.Id),
		},
		LocalMemoryMiB:  -1, // Not implemented
		RemoteMemoryMiB: -1, // Not implemented
	}

	return openapi.Response(http.StatusOK, h), nil
}

func formatErrorResp(ctx context.Context, re *common.RequestError) (openapi.ImplResponse, error) {
	// Use the Go language type assertion to convert the returned enhanced error into the RequestError type
	status := openapi.StatusMessage{
		Uri:     common.GetContextString(ctx, common.KeyUri),
		Details: re.Error(),
		Status: openapi.StatusMessageStatus{
			Code:    int32(re.StatusCode),
			Message: re.StatusCode.String(),
		},
	}
	return openapi.Response(re.StatusCode.HttpStatusCode(), status), nil
}

type CfmVersionType struct {
	Version string `json:"v1"`
}

// CfmGet -
func (cfm *CfmApiService) CfmGet(ctx context.Context) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### CfmGet")

	response := CfmVersionType{
		Version: "/cfm/v1",
	}

	return openapi.Response(http.StatusOK, response), nil
}

// CfmV1Get -
func (cfm *CfmApiService) CfmV1Get(ctx context.Context) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### CfmV1Get")

	response := openapi.ServiceInformation{
		Version: cfm.Version,
	}

	response.Resources = append(response.Resources, openapi.ServiceResource{
		Uri:         manager.GetCfmUriAppliances(),
		Methods:     "GET, POST",
		Description: "Manage retrieval and addition of memory appliances under cfm-service management",
	})

	response.Resources = append(response.Resources, openapi.ServiceResource{
		Uri:         manager.GetCfmUriHosts(),
		Methods:     "GET, POST",
		Description: "Manage retrieval and addition of CXL hosts under cfm-service management",
	})

	return openapi.Response(http.StatusOK, response), nil
}

// RootGet -
func (cfm *CfmApiService) RootGet(ctx context.Context) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### RootGet")

	response := openapi.StatusMessage{
		Uri:     "/",
		Details: fmt.Sprintf("Composable Fabric Manager (CFM) Service API. Use 'http get /cfm' to see supported versions."),
		Status: openapi.StatusMessageStatus{
			Code:    int32(common.StatusOK),
			Message: common.StatusOK.String(),
		},
	}
	return openapi.Response(http.StatusOK, response), nil
}

// DiscoverDevices -
func (cfm *CfmApiService) DiscoverDevices(ctx context.Context, deviceType string) (openapi.ImplResponse, error) {
	mu.Lock()
	defer mu.Unlock()

	logger := klog.FromContext(ctx)
	logger.V(4).Info("###### DiscoverDevices")

	if deviceType != "blade" && deviceType != "cxl-host" {
		err := common.RequestError{
			StatusCode: common.StatusDeviceDiscoveryFailure,
			Err:        fmt.Errorf("invalid type parameter"),
		}
		return formatErrorResp(ctx, &err)
	}

	// Save the input deviceType to originDeviceType and change the deviceType to match service.txt
	originDeviceType := deviceType
	if deviceType == "blade" {
		deviceType = "cma"
	}

	conn, err := dbus.SystemBus()
	if err != nil {
		return formatErrorResp(ctx, &common.RequestError{
			StatusCode: common.StatusDeviceDiscoveryFailure,
			Err:        fmt.Errorf("cannot get system bus: %v", err),
		})
	}

	server, err := avahi.ServerNew(conn)
	if err != nil {
		return formatErrorResp(ctx, &common.RequestError{
			StatusCode: common.StatusDeviceDiscoveryFailure,
			Err:        fmt.Errorf("avahi new failed: %v", err),
		})
	}

	// Specify avahi.ProtoInet for IPv4
	sb, err := server.ServiceBrowserNew(avahi.InterfaceUnspec, avahi.ProtoInet, "_obmc_redfish._tcp", "local", 0)
	if err != nil {
		return formatErrorResp(ctx, &common.RequestError{
			StatusCode: common.StatusDeviceDiscoveryFailure,
			Err:        fmt.Errorf("service browser new failed: %v", err),
		})
	}

	var devices []*openapi.DiscoveredDevice
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	// Channel to signal when no new services are found
	noNewServices := make(chan struct{})

	go func() {
		for {
			select {
			case <-time.After(500 * time.Millisecond):
				close(noNewServices)
				return
			case <-ctx.Done():
				return
			}
		}
	}()

	for {
		select {
		case service := <-sb.AddChannel:
			log.Println("ServiceBrowser ADD: ", service)

			resolvedService, err := server.ResolveService(service.Interface, service.Protocol, service.Name,
				service.Type, service.Domain, avahi.ProtoInet, 0)
			if err == nil {
				// filter the servers by deviceType
				if strings.Contains(string(resolvedService.Txt[0]), deviceType) {
					currentDevice := &openapi.DiscoveredDevice{
						Name:    resolvedService.Host,
						Address: resolvedService.Address,
						Port:    int32(resolvedService.Port),
						Type:    originDeviceType,
					}
					devices = append(devices, currentDevice)
				}

			} else {
				log.Printf("Failed to resolve service: %v", err)
			}

		case service := <-sb.RemoveChannel:
			log.Println("ServiceBrowser REMOVE: ", service)

		case <-noNewServices:
			log.Println("No new services found, stopping discovery")
			cancel()

		case <-ctx.Done():
			return openapi.Response(http.StatusOK, devices), nil
		}
	}
}
