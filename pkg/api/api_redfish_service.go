// Copyright (c) 2024 Seagate Technology LLC and/or its Affiliates
/*
Composable Fabric Manager Service OpenAPI

This API allows users to interact through the CFM Service with CXL Hosts and Memory Appliances. The main purpose of this interface is to allow the retrieval of information and the creation and mapping of memory from a Memory Appliance to a CXL host.

API version: 1.7.0
Generated by: OpenAPI Generator (https://openapi-generator.tech)
*/

package api

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"slices"
	"sort"
	"strconv"
	"strings"

	"cfm/pkg/backend"
	"cfm/pkg/common"
	"cfm/pkg/manager"
	"cfm/pkg/redfishapi"
)

// NewRedfishApiService creates a default api service
func NewRedfishApiService(version string) redfishapi.DefaultAPIServicer {
	return &CfmApiService{Version: version}
}

// RedfishGet -
func (cfm *CfmApiService) RedfishGet(ctx context.Context) (redfishapi.ImplResponse, error) {

	version := CfmVersionType{
		Version: "/redfish/v1",
	}

	return redfishapi.Response(http.StatusOK, version), nil
}

// RedfishV1ChassisChassisIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdGet(ctx context.Context, chassisId string) (redfishapi.ImplResponse, error) {
	_, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.ChassisV1250Chassis{
		// OdataContext: "/redfish/v1/$metadata#Chassis.Chassis",
		// OdataEtag:                    "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId,
		OdataType: "#Chassis_v1_25_0_Chassis",
		// Actions:                      redfishapi.ChassisV1250Actions{},
		// Assembly:                     redfishapi.OdataV4IdRef{},
		// AssetTag:                     new(string),
		// Certificates:                 redfishapi.OdataV4IdRef{},
		// ChassisType:                  "",
		// Controls:                     redfishapi.OdataV4IdRef{},
		// DepthMm:                      new(float32),
		// Description:                  "",
		// Doors:                        redfishapi.ChassisV1250Doors{},
		// Drives:                       redfishapi.OdataV4IdRef{},
		// ElectricalSourceManagerURIs:  []*string{},
		// ElectricalSourceNames:        []*string{},
		// EnvironmentMetrics:           redfishapi.OdataV4IdRef{},
		// EnvironmentalClass:           "",
		// FabricAdapters:               redfishapi.OdataV4IdRef{},
		// HeatingCoolingEquipmentNames: []*string{},
		// HeatingCoolingManagerURIs:    []*string{},
		// HeightMm:                     new(float32),
		// HotPluggable:                 new(bool),
		Id: chassisId,
		// IndicatorLED:                 "",
		// Links:                        redfishapi.ChassisV1250Links{},
		// Location:                     redfishapi.ResourceLocation{},
		// LocationIndicatorActive:      new(bool),
		// LogServices:                  redfishapi.OdataV4IdRef{},
		// Manufacturer:                 new(string),
		// MaxPowerWatts:                new(float32),
		// Measurements:                 []redfishapi.SoftwareInventoryMeasurementBlock{},
		// MediaControllers:             redfishapi.OdataV4IdRef{},
		// Memory: redfishapi.OdataV4IdRef{
		// 	OdataId: "/redfish/v1/Chassis/" + chassisId + "/Memory",
		// },
		MemoryDomains: redfishapi.OdataV4IdRef{
			OdataId: "/redfish/v1/Chassis/" + chassisId + "/MemoryDomains",
		},
		// MinPowerWatts:   new(float32),
		// Model:           new(string),
		Name: chassisId,
		// NetworkAdapters: redfishapi.OdataV4IdRef{},
		// Oem:             map[string]interface{}{},
		PCIeDevices: redfishapi.OdataV4IdRef{
			OdataId: "/redfish/v1/Chassis/" + chassisId + "/PCIeDevices",
		},
		// PCIeSlots:              redfishapi.OdataV4IdRef{},
		// PartNumber:             new(string),
		// PhysicalSecurity:       redfishapi.ChassisV1250PhysicalSecurity{},
		// Power:                  redfishapi.OdataV4IdRef{},
		// PowerState:             "",
		// PowerSubsystem:         redfishapi.OdataV4IdRef{},
		// PoweredByParent:        new(bool),
		// Processors:             redfishapi.OdataV4IdRef{},
		// Replaceable:            new(bool),
		// SKU:                    new(string),
		// Sensors:                redfishapi.OdataV4IdRef{},
		// SerialNumber:           new(string),
		// SparePartNumber:        new(string),
		// Status:                 redfishapi.ResourceStatus{},
		// Thermal:                redfishapi.OdataV4IdRef{},
		// ThermalDirection:       "",
		// ThermalManagedByParent: new(bool),
		// ThermalSubsystem:       redfishapi.OdataV4IdRef{},
		// TrustedComponents:      redfishapi.OdataV4IdRef{},
		// UUID:                   "",
		// Version:                new(string),
		// WeightKg:               new(float32),
		// WidthMm:                new(float32),
	}), nil

}

// RedfishV1ChassisChassisIdMemoryDomainsGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryDomainsGet(ctx context.Context, chassisId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	domains := host.GetRedfishMemoryDomains(ctx)
	sort.Strings(domains)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range domains {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s", chassisId, member)})
	}

	return redfishapi.Response(200, redfishapi.MemoryDomainCollectionMemoryDomainCollection{
		// OdataContext: "#MemoryDomainCollection.MemoryDomainCollection",
		// OdataEtag:         "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/MemoryDomains",
		OdataType: "#MemoryDomainCollection.MemoryDomainCollection",
		// Description:       "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "MemoryDomain Collection",
		// Oem:                  map[string]interface{}{},
	}), nil

}

// RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdGet(ctx context.Context, chassisId string, memoryDomainId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = host.GetMemoryDomainAllMemoryIds(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// memory chunks
	return redfishapi.Response(200, redfishapi.MemoryDomainV150MemoryDomain{
		// OdataContext: "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/MemoryDomains/" + memoryDomainId,
		OdataType: "#MemoryDomain.v1_5_0.MemoryDomain",
		// Actions:                   redfishapi.MemoryDomainV150Actions{},
		// AllowsBlockProvisioning:   new(bool),
		// AllowsMemoryChunkCreation: new(bool),
		// AllowsMirroring:           new(bool),
		// AllowsSparing:             new(bool),
		// Description:               "",
		Id: memoryDomainId,
		// InterleavableMemorySets:   []redfishapi.MemoryDomainV150MemorySet{},
		// Links:                     redfishapi.MemoryDomainV150Links{},
		// MemoryChunkIncrementMiB:   new(int64),
		MemoryChunks: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s/MemoryChunks", chassisId, memoryDomainId),
		},
		// MemorySizeMiB:             new(int64),
		// MinMemoryChunkSizeMiB:     new(int64),
		Name: "Memory Domain",
		// Oem:                       map[string]interface{}{},
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdMemoryChunksGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdMemoryChunksGet(ctx context.Context, chassisId string, memoryDomainId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := host.GetMemoryDomainAllMemoryIds(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by memory id
	sort.Strings(memory)

	members := []redfishapi.OdataV4IdRef{}
	for _, member := range memory {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s/MemoryChunks/%s", chassisId, memoryDomainId, member)})
	}

	return redfishapi.Response(200, redfishapi.MemoryChunksCollectionMemoryChunksCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s/MemoryChunks", chassisId, memoryDomainId),
		OdataType: "#MemoryChunksCollection.MemoryChunksCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "",
		// Oem:                  map[string]interface{}{},
	}), nil

}

// RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdGet(ctx context.Context, chassisId string, memoryDomainId string, memoryChunksId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memorydomain, err := host.GetMemoryDomainAllMemoryIds(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	if !slices.Contains(memorydomain, memoryChunksId) {
		return redfishapi.Response(http.StatusNotFound, fmt.Errorf("memory chunk id (%s) does not exist", memoryChunksId)), nil
	}

	memory, err := host.GetMemoryById(ctx, memoryChunksId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memory.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	sizeMiB := int64(details.SizeMiB)
	return redfishapi.Response(200, redfishapi.MemoryChunksV161MemoryChunks{
		// OdataContext: "",
		// OdataEtag:                 "",
		OdataId:   fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s/MemoryChunks/%s", chassisId, memoryDomainId, memoryChunksId),
		OdataType: "#MemoryChunks.V1_6_1.MemoryChunks",
		// Actions:                   redfishapi.MemoryChunksV161Actions{},
		// AddressRangeOffsetMiB:     new(int64),
		// AddressRangeType:          "",
		// Description:               "",
		// DisplayName:               new(string),
		Id: memoryChunksId,
		// InterleaveSets:            []redfishapi.MemoryChunksV161InterleaveSet{},
		// IsMirrorEnabled:           new(bool),
		// IsSpare:                   new(bool),
		// Links:                     redfishapi.MemoryChunksV161Links{},
		// MediaLocation:             "",
		MemoryChunkSizeMiB: &sizeMiB,
		Name:               memoryChunksId,
		// Oem:                       map[string]interface{}{},
		// RequestedOperationalState: "",
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1ChassisChassisIdPCIeDevicesGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesGet(ctx context.Context, chassisId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by memory device id
	memdevIds := host.GetAllMemoryDeviceIds()
	sort.Strings(memdevIds)

	members := []redfishapi.OdataV4IdRef{}
	for _, member := range memdevIds {
		memdevBade := strings.Split(member, ".")[0]
		pcieDevId := memdevBade[6:]
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/PCIeDevices/%s", chassisId, pcieDevId)})
	}

	return redfishapi.Response(200, redfishapi.PcieDeviceCollectionPcieDeviceCollection{
		// OdataContext: "/redfish/v1/$metadata#PCIeDeviceCollection.PCIeDeviceCollection",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/PCIeDevices",
		OdataType: "#PCIeDeviceCollection.PCIeDeviceCollection",
		// Description:       "PCIeDevice Collection",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "PCIeDevice Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdCXLLogicalDevicesCXLLogicalDeviceIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdCXLLogicalDevicesCXLLogicalDeviceIdGet(ctx context.Context, chassisId string, pCIeDeviceId string, cXLLogicalDeviceId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memdev, err := host.GetMemoryDeviceById(ctx, fmt.Sprintf("memdev%s.0", pCIeDeviceId))
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	if cXLLogicalDeviceId != memdev.LogicalDeviceId {
		return redfishapi.Response(http.StatusNotFound, fmt.Errorf("cxlLogicalDevice id (%s) does not exist", cXLLogicalDeviceId)), nil
	}

	details, err := memdev.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	return redfishapi.Response(200, redfishapi.CxlLogicalDeviceV111CxlLogicalDevice{
		// OdataContext:             "",
		// OdataEtag:                "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/PCIeDevices/" + pCIeDeviceId + "/CXLLogicalDevices/" + cXLLogicalDeviceId,
		OdataType: "#CXLLogicalDevice.v1_1_1.CXLLogicalDevice",
		// Actions:                  redfishapi.CxlLogicalDeviceV111Actions{},
		// Description:              "",
		Id:          cXLLogicalDeviceId,
		Identifiers: []redfishapi.ResourceIdentifier{},
		// Links:                    redfishapi.CxlLogicalDeviceV111Links{},
		// Log:                      redfishapi.OdataV4IdRef{},
		// MemoryRegions:            redfishapi.OdataV4IdRef{},
		MemorySizeMiB: int64(details.MemorySizeMiB),
		Name:          cXLLogicalDeviceId,
		// Oem:                      map[string]interface{}{},
		// QoS:                      redfishapi.CxlLogicalDeviceV111QoS{},
		// QoSTelemetryCapabilities: redfishapi.CxlLogicalDeviceV111QoSTelemetryCapabilities{},
		// SemanticsSupported:       []redfishapi.CxlLogicalDeviceV111CxlSemantic{},
		// Status:                   redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdCXLLogicalDevicesGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdCXLLogicalDevicesGet(ctx context.Context, chassisId string, pCIeDeviceId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memdev, err := host.GetMemoryDeviceById(ctx, fmt.Sprintf("memdev%s.0", pCIeDeviceId))
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	members := []redfishapi.OdataV4IdRef{}
	members = append(members, redfishapi.OdataV4IdRef{
		OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/PCIeDevices/%s/CXLLogicalDevices/%s", chassisId, memdev.PhysicalDeviceId, memdev.LogicalDeviceId)})

	return redfishapi.Response(200, redfishapi.CxlLogicalDeviceCollectionCxlLogicalDeviceCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   fmt.Sprintf("/redfish/v1/Chassis/%s/PCIeDevices/%s/CXLLogicalDevices", chassisId, pCIeDeviceId),
		OdataType: "#CXLLogicalDeviceCollection.CXLLogicalDeviceCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "CXL Logical Device Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdGet(ctx context.Context, chassisId string, pCIeDeviceId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = host.GetMemoryDeviceById(ctx, fmt.Sprintf("memdev%s.0", pCIeDeviceId))
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.PcieDeviceV1130PcieDevice{
		// OdataContext:            "",
		// OdataEtag:               "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/PCIeDevices/" + pCIeDeviceId,
		OdataType: "#PCIeDevice.v1_13_0.PCIeDevice",
		// Actions:                 redfishapi.PcieDeviceV1130Actions{},
		// Assembly:                redfishapi.OdataV4IdRef{},
		// AssetTag:                new(string),
		// CXLDevice:               redfishapi.PcieDeviceV1130CxlDevice{},
		CXLLogicalDevices: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/PCIeDevices/%s/CXLLogicalDevices", chassisId, pCIeDeviceId),
		},
		// Description:             "",
		// DeviceType:              "",
		// EnvironmentMetrics:      redfishapi.OdataV4IdRef{},
		// FirmwareVersion:         new(string),
		Id: pCIeDeviceId,
		// Links:                   redfishapi.PcieDeviceV1130Links{},
		// LocationIndicatorActive: new(bool),
		// Manufacturer:            new(string),
		// Model:                   new(string),
		Name: pCIeDeviceId,
		// Oem:                     map[string]interface{}{},
		// PCIeFunctions:           redfishapi.OdataV4IdRef{},
		// PCIeInterface:           redfishapi.PcieDeviceV1130PcieInterface{},
		// PartNumber:              new(string),
		// ReadyToRemove:           new(bool),
		// SKU:                     new(string),
		// SerialNumber:            new(string),
		// Slot:                    redfishapi.PcieDeviceV1130Slot{},
		// SparePartNumber:         new(string),
		// StagedVersion:           "",
		// Status:                  redfishapi.ResourceStatus{},
		// UUID:                    "",
	}), nil
}

// RedfishV1ChassisGet -
func (cfm *CfmApiService) RedfishV1ChassisGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	hostIds := manager.GetAllHostIds()
	sort.Strings(hostIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range hostIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s", member)})
	}

	return redfishapi.Response(200, redfishapi.ChassisCollectionChassisCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Chassis",
		OdataType: "#ChassisCollection.ChassisCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Chassis Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdConnectionsConnectionIdDelete -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdConnectionsConnectionIdDelete(ctx context.Context, fabricId string, connectionId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	connectionSplit := strings.Split(connectionId, "connection")
	bladeId := connectionSplit[0]
	memoryChunkId := "memorychunk" + connectionSplit[1]

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.GetMemoryById(ctx, memoryChunkId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memory.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	if details.MemoryAppliancePort == "" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: Connection Type (%s) does not exist", connectionId)), nil
	}

	r := manager.RequestAssignMemory{
		MemoryId:  memoryChunkId,
		PortId:    details.MemoryAppliancePort,
		Operation: "unassign",
	}

	_, err = blade.AssignMemory(ctx, &r)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	return redfishapi.Response(200, redfishapi.ConnectionV131Connection{
		// OdataContext: "",
		// OdataEtag:        "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Connections/" + connectionId,
		OdataType: "#Connection.V1_3_1.Connection",
		// Actions:        redfishapi.ConnectionV131Actions{},
		// ConnectionKeys: redfishapi.ConnectionV131ConnectionKey{},
		ConnectionType: "CXL",
		// Description:      "",
		Id: connectionId,
		Links: redfishapi.ConnectionV131Links{TargetEndpoints: []redfishapi.OdataV4IdRef{
			{OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, bladeId+strings.Replace(details.MemoryAppliancePort, "port", "up", 1))},
		}},
		MemoryChunkInfo: []redfishapi.ConnectionV131MemoryChunkInfo{{MemoryChunk: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks/%s", fabricId, bladeId, memoryChunkId),
		}}},
		// MemoryRegionInfo: []redfishapi.ConnectionV131MemoryRegionInfo{},
		Name: connectionId,
		// Oem:              map[string]interface{}{},
		// Status:     redfishapi.ResourceStatus{},
		// VolumeInfo: []redfishapi.ConnectionV131VolumeInfo{},
	}), nil
}

// RedfishV1FabricsFabricIdConnectionsConnectionIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdConnectionsConnectionIdGet(ctx context.Context, fabricId string, connectionId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	connectionSplit := strings.Split(connectionId, "connection")
	bladeId := connectionSplit[0]
	memoryChunkId := "memorychunk" + connectionSplit[1]

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.GetMemoryById(ctx, memoryChunkId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memory.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	if details.MemoryAppliancePort == "" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: Connection Type (%s) does not exist", connectionId)), nil
	}

	return redfishapi.Response(200, redfishapi.ConnectionV131Connection{
		// OdataContext: "",
		// OdataEtag:        "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Connections/" + connectionId,
		OdataType: "#Connection.V1_3_1.Connection",
		// Actions:        redfishapi.ConnectionV131Actions{},
		// ConnectionKeys: redfishapi.ConnectionV131ConnectionKey{},
		ConnectionType: "",
		// Description:      "",
		Id: fabricId,
		Links: redfishapi.ConnectionV131Links{TargetEndpoints: []redfishapi.OdataV4IdRef{
			{OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, bladeId+strings.Replace(details.MemoryAppliancePort, "port", "up", 1))},
		}},
		MemoryChunkInfo: []redfishapi.ConnectionV131MemoryChunkInfo{{MemoryChunk: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks/%s", fabricId, bladeId, memoryChunkId),
		}}},
		// MemoryRegionInfo: []redfishapi.ConnectionV131MemoryRegionInfo{},
		Name: fabricId,
		// Oem:              map[string]interface{}{},
		// Status:     redfishapi.ResourceStatus{},
		// VolumeInfo: []redfishapi.ConnectionV131VolumeInfo{},
	}), nil
}

// RedfishV1FabricsFabricIdConnectionsGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdConnectionsGet(ctx context.Context, fabricId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	members := []redfishapi.OdataV4IdRef{}
	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)
	for _, bladeId := range bladeIds {
		blade, err := appliance.GetBladeById(ctx, bladeId)
		if err != nil {
			return formatRedfishErrorResp(ctx, err.(*common.RequestError))
		}
		memoryIds := blade.GetAllMemoryIds()
		sort.Strings(memoryIds)

		for _, memId := range memoryIds {
			mem, err := blade.GetMemoryById(ctx, memId)
			if err != nil {
				return formatRedfishErrorResp(ctx, err.(*common.RequestError))
			}
			details, err := mem.GetDetails(ctx)
			if err != nil {
				return formatRedfishErrorResp(ctx, err.(*common.RequestError))
			}
			if details.MemoryAppliancePort != "" {
				connectionId := bladeId + strings.Replace(mem.Id, "memorychunk", "connection", 1)
				members = append(members, redfishapi.OdataV4IdRef{
					OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Connections/%s", fabricId, connectionId)})
			}
		}
	}

	return redfishapi.Response(200, redfishapi.ConnectionCollectionConnectionCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Connections",
		OdataType: "#ConnectionCollection.ConnectionCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Connection Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdConnectionsPost -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdConnectionsPost(ctx context.Context, fabricId string, connectionV131Connection redfishapi.ConnectionV131Connection) (redfishapi.ImplResponse, error) {

	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	if connectionV131Connection.ConnectionType != "CXL" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: Connection Type (%s) does not support", connectionV131Connection.ConnectionType)), nil
	}

	targetBladeId := ""
	r := manager.RequestAssignMemory{
		MemoryId:  "",
		PortId:    "",
		Operation: "assign",
	}

	// check format
	if len(connectionV131Connection.MemoryChunkInfo) == 0 {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: MemoryChunkInfo needs to be supplied")), nil
	}
	memoryChunkOdataId := connectionV131Connection.MemoryChunkInfo[0].MemoryChunk.OdataId
	if len(connectionV131Connection.Links.TargetEndpoints) == 0 {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: TargetEndpoints needs to be supplied")), nil
	}
	endpointOdataId := connectionV131Connection.Links.TargetEndpoints[0].OdataId

	for bladeId, blade := range appliance.GetBlades(ctx) {
		for _, memoryId := range blade.GetAllMemoryIds() {
			if fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks/%s", fabricId, bladeId, memoryId) == memoryChunkOdataId {
				targetBladeId = bladeId
				r.MemoryId = memoryId
				break
			}
		}
		if r.MemoryId == "" {
			continue
		}
		for _, portid := range blade.GetAllPortIds() {
			if fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, bladeId+strings.Replace(portid, "port", "up", 1)) == endpointOdataId {
				r.PortId = portid
				break
			}
		}
		if r.PortId != "" {
			targetBladeId = bladeId
			break
		}
	}

	if r.MemoryId == "" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: memory chunk (%s) not found", memoryChunkOdataId)), nil

	}

	if r.PortId == "" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: Endpoint (%s) not found", endpointOdataId)), nil
	}

	blade, err := appliance.GetBladeById(ctx, targetBladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.AssignMemory(ctx, &r)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	connectionId := targetBladeId + strings.Replace(memory.Id, "memorychunk", "connection", 1)

	return redfishapi.Response(201, redfishapi.ConnectionV131Connection{
		// OdataContext: "",
		// OdataEtag:        "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Connections/" + connectionId,
		OdataType: "#Connection.V1_3_1.Connection",
		// Actions:        redfishapi.ConnectionV131Actions{},
		// ConnectionKeys: redfishapi.ConnectionV131ConnectionKey{},
		ConnectionType: "",
		// Description:      "",
		Id:              connectionId,
		Links:           redfishapi.ConnectionV131Links{},
		MemoryChunkInfo: []redfishapi.ConnectionV131MemoryChunkInfo{},
		// MemoryRegionInfo: []redfishapi.ConnectionV131MemoryRegionInfo{},
		Name: connectionId,
		// Oem:              map[string]interface{}{},
		// Status:     redfishapi.ResourceStatus{},
		// VolumeInfo: []redfishapi.ConnectionV131VolumeInfo{},
	}), nil
}

// RedfishV1FabricsFabricIdEndpointsEndpointIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdEndpointsEndpointIdGet(ctx context.Context, fabricId string, endpointId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	endpointIdSplit := strings.Split(endpointId, "up")
	bladeId := endpointIdSplit[0]
	portId := "port" + endpointIdSplit[1]
	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = blade.GetPortById(ctx, portId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// details, err := port.GetDetails(ctx)
	// if err != nil {
	// 	return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	// }

	links := redfishapi.EndpointV181Links{
		ConnectedPorts: []redfishapi.OdataV4IdRef{
			{OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches/%s/Ports/%s", fabricId, bladeId, portId)},
		},
		ConnectedPortsodataCount: 1,
		// Connections:                          []redfishapi.OdataV4IdRef{},
		// ConnectionsodataCount:                0,
	}
	return redfishapi.Response(200, redfishapi.EndpointV181Endpoint{
		// OdataContext:               "",
		// OdataEtag:                  "",
		OdataId:   fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, endpointId),
		OdataType: "#Endpoint.v1_8_1.Endpoint",
		// Actions:                    redfishapi.EndpointV181Actions{},
		// ConnectedEntities: []redfishapi.EndpointV181ConnectedEntity{},
		// Description:                "",
		// EndpointProtocol:           "",
		// HostReservationMemoryBytes: new(int64),
		// IPTransportDetails:         []redfishapi.EndpointV181IpTransportDetails{},
		Id:          endpointId,
		Identifiers: []redfishapi.ResourceIdentifier{},
		Links:       links,
		Name:        endpointId,
		// Oem:                        map[string]interface{}{},
		// PciId:                      redfishapi.EndpointV181PciId{},
		// Redundancy:                 []redfishapi.RedundancyRedundancy{},
		// RedundancyodataCount:       0,
		// Status:                     redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1FabricsFabricIdEndpointsGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdEndpointsGet(ctx context.Context, fabricId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)

	members := []redfishapi.OdataV4IdRef{}
	for _, bladeId := range bladeIds {
		blade, _ := appliance.GetBladeById(ctx, bladeId)
		for _, portid := range blade.GetAllPortIds() {
			members = append(members, redfishapi.OdataV4IdRef{
				OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, bladeId+strings.Replace(portid, "port", "up", 1))})
		}
	}

	return redfishapi.Response(200, redfishapi.EndpointCollectionEndpointCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints", fabricId),
		OdataType: "#EndpointsCollection.EndpointsCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdGet(ctx context.Context, fabricId string) (redfishapi.ImplResponse, error) {
	_, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.FabricV131Fabric{
		// OdataContext:   "",
		// OdataEtag:      "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId,
		OdataType: "#Fabric.v1_3_1.Fabric",
		// Actions:        redfishapi.FabricV131Actions{},
		// AddressPools:   redfishapi.OdataV4IdRef{},
		Connections: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Connections", fabricId),
		},
		// Description:    "",
		// EndpointGroups: redfishapi.OdataV4IdRef{},
		Endpoints: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints", fabricId),
		},
		FabricType: "Memory Appliance",
		Id:         fabricId,
		// Links:          redfishapi.FabricV131Links{},
		// MaxZones:       new(int64),
		Name: fabricId,
		// Oem:            map[string]interface{}{},
		// Status:         redfishapi.ResourceStatus{},
		Switches: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches", fabricId),
		},
		// UUID:           "",
		// Zones:          redfishapi.OdataV4IdRef{},
	}), nil
}

// RedfishV1FabricsFabricIdSwitchesGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdSwitchesGet(ctx context.Context, fabricId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by blade id
	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)

	members := []redfishapi.OdataV4IdRef{}
	for _, member := range bladeIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches/%s", fabricId, member)})
	}

	return redfishapi.Response(200, redfishapi.SwitchCollectionSwitchCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Switches",
		OdataType: "#SwitchCollection.SwitchCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Switch Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdSwitchesSwitchIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdSwitchesSwitchIdGet(ctx context.Context, fabricId string, switchId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = appliance.GetBladeById(ctx, switchId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.SwitchV192Switch{
		// OdataContext:            "",
		// OdataEtag:               "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Switches/" + switchId,
		OdataType: "#Switch.v1_9_2.Switch",
		// Actions:                 redfishapi.SwitchV192Actions{},
		// AssetTag:                new(string),
		// CXL:                     redfishapi.SwitchV192Cxl{},
		// Certificates:            redfishapi.OdataV4IdRef{},
		// CurrentBandwidthGbps:    new(float32),
		// Description:             "",
		// DomainID:                new(int64),
		// Enabled:                 false,
		// EnvironmentMetrics:      redfishapi.OdataV4IdRef{},
		// FirmwareVersion:         new(string),
		Id: switchId,
		// IndicatorLED:            "",
		// IsManaged:               new(bool),
		// Links:                   redfishapi.SwitchV192Links{},
		// Location:                redfishapi.ResourceLocation{},
		// LocationIndicatorActive: new(bool),
		// LogServices:             redfishapi.OdataV4IdRef{},
		// Manufacturer:            new(string),
		// MaxBandwidthGbps:        new(float32),
		// Measurements:            []redfishapi.SoftwareInventoryMeasurementBlock{},
		// Metrics:                 redfishapi.OdataV4IdRef{},
		// Model:                   new(string),
		Name: switchId,
		// Oem:                     map[string]interface{}{},
		// PartNumber:              new(string),
		Ports: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches/%s/Ports", fabricId, switchId),
		},
		// PowerState:              "",
		// Redundancy:              []redfishapi.RedundancyRedundancy{},
		// RedundancyodataCount:    0,
		// SKU:                     new(string),
		// SerialNumber:            new(string),
		// Status:                  redfishapi.ResourceStatus{},
		// SupportedProtocols:      []redfishapi.ProtocolProtocol{},
		// SwitchType:              "",
		// TotalSwitchWidth:        new(int64),
		// UUID:                    "",
	}), nil
}

// RedfishV1FabricsFabricIdSwitchesSwitchIdPortsGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdSwitchesSwitchIdPortsGet(ctx context.Context, fabricId string, switchId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, switchId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by port id
	portIds := blade.GetAllPortIds()
	sort.Strings(portIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range portIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches/%s/Ports/%s", fabricId, switchId, member)})
	}

	return redfishapi.Response(200, redfishapi.PortCollectionPortCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Switches/" + switchId + "/Ports",
		OdataType: "#PortCollection.PortCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Port Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdSwitchesSwitchIdPortsPortIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdSwitchesSwitchIdPortsPortIdGet(ctx context.Context, fabricId string, switchId string, portId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, switchId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	port, err := blade.GetPortById(ctx, portId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = port.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.PortV1110Port{
		// OdataContext:            "",
		// OdataEtag:               "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Switches/" + switchId + "/Ports/" + portId,
		OdataType: "#Port.v1_11_1.Port",
		// Actions:                 redfishapi.PortV1110Actions{},
		// ActiveWidth:      details.Width,
		// CXL:                     redfishapi.PortV1110Cxl{},
		// CapableProtocolVersions: []*string{},
		// CurrentProtocolVersion:  new(string),
		// CurrentSpeedGbps:        new(float32),
		// Description:             "",
		// Enabled:                 false,
		// EnvironmentMetrics:      redfishapi.OdataV4IdRef{},
		// Ethernet:                redfishapi.PortV1110EthernetProperties{},
		// FibreChannel:            redfishapi.PortV1110FibreChannelProperties{},
		// FunctionMaxBandwidth:    []redfishapi.PortV1110FunctionMaxBandwidth{},
		// FunctionMinBandwidth:    []redfishapi.PortV1110FunctionMinBandwidth{},
		// GenZ:                    redfishapi.PortV1110GenZ{},
		Id: portId,
		// InfiniBand:              redfishapi.PortV1110InfiniBandProperties{},
		// InterfaceEnabled:        new(bool),
		// LinkConfiguration:       []redfishapi.PortV1110LinkConfiguration{},
		// LinkNetworkTechnology:   "",
		// LinkState:               "",
		// LinkStatus:              "",
		// LinkTransitionIndicator: 0,
		// Links:                   redfishapi.PortV1110Links{},
		// Location:                redfishapi.ResourceLocation{},
		// LocationIndicatorActive: new(bool),
		// MaxFrameSize:            new(int64),
		// MaxSpeedGbps:            new(float32),
		// Metrics:                 redfishapi.OdataV4IdRef{},
		Name: portId,
		// Oem:                     map[string]interface{}{},
		// PortId:                  new(string),
		// PortMedium:              "",
		// PortProtocol:            "",
		// PortType:                "",
		// RemotePortId:            new(string),
		// SFP:                     redfishapi.PortV1110Sfp{},
		// SignalDetected:          new(bool),
		// Status:                  redfishapi.ResourceStatus{},
		// Width:                   new(int64),
	}), nil
}

// RedfishV1FabricsGet -
func (cfm *CfmApiService) RedfishV1FabricsGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	// order returned uris by appliance id
	applianceIds := manager.GetAllApplianceIds()
	sort.Strings(applianceIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range applianceIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s", member)})
	}

	return redfishapi.Response(200, redfishapi.FabricCollectionFabricCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Fabrics",
		OdataType: "#FabricCollection.FabricCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Fabric Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1Get -
func (cfm *CfmApiService) RedfishV1Get(ctx context.Context) (redfishapi.ImplResponse, error) {
	vendor := "Seagate"
	product := "Memory Appliance Composer & Fabric Manager Redfish Service"

	oem := map[string]interface{}{}
	oem["ServiceVersion"] = cfm.Version

	root := redfishapi.ServiceRootV1161ServiceRoot{
		// OdataContext: "/redfish/v1/$metadata#ServiceRoot.ServiceRoot",
		OdataId:   "/redfish/v1",
		OdataType: "#ServiceRoot.v1_16_1.ServiceRoot",
		Chassis:   redfishapi.OdataV4IdRef{OdataId: "/redfish/v1/Chassis"},
		// Description:    "CXL Host ServiceRoot",
		Fabrics: redfishapi.OdataV4IdRef{OdataId: "/redfish/v1/Fabrics"},
		Id:      "CXL Host ServiceRoot",
		Name:    "CXL Host",
		// Oem:            oem,
		Product:        &product,
		RedfishVersion: "1.20.0",
		Systems:        redfishapi.OdataV4IdRef{OdataId: "/redfish/v1/Systems"},
		Vendor:         &vendor,
	}

	return redfishapi.Response(http.StatusOK, root), nil
}

// RedfishV1MetadataGet -
func (cfm *CfmApiService) RedfishV1MetadataGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	metadata := `<?xml version="1.0" encoding="UTF-8"?>
	<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
		<edmx:DataServices>
			<Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="Service">
				<EntityContainer Name="Service" Extends="ServiceRoot.v1_2_0.ServiceContainer" />
			</Schema>
		</edmx:DataServices>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Chassis_v1.xml">
			<edmx:Include Namespace="Chassis" />
				<edmx:Include Namespace="Chassis.v1_21_0" />
		</edmx:Reference>
			<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/ChassisCollection_v1.xml">
				<edmx:Include Namespace="ChassisCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Fabric_v1.xml">
			<edmx:Include Namespace="Fabric" />
				<edmx:Include Namespace="Fabric.v1_3_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/FabricCollection_v1.xml">
			<edmx:Include Namespace="FabricCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Memory_v1.xml">
			<edmx:Include Namespace="Memory" />
				<edmx:Include Namespace="Memory.v1_16_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryCollection_v1.xml">
			<edmx:Include Namespace="MemoryCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Port_v1.xml">
			<edmx:Include Namespace="Port" />
				<edmx:Include Namespace="Port.v1_7_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/PortCollection_v1.xml">
			<edmx:Include Namespace="PortCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Switch_v1.xml">
			<edmx:Include Namespace="Switch" />
				<edmx:Include Namespace="Switch.v1_8_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/SwitchCollection_v1.xml">
			<edmx:Include Namespace="SwitchCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryDomain_v1.xml">
			<edmx:Include Namespace="MemoryDomain" />
				<edmx:Include Namespace="MemoryDomain.v1_5_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryDomainCollection_v1.xml">
			<edmx:Include Namespace="MemoryDomainCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryChunks_v1.xml">
			<edmx:Include Namespace="MemoryChunks" />
				<edmx:Include Namespace="MemoryChunks.v1_6_1" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryChunksCollection_v1.xml">
			<edmx:Include Namespace="MemoryChunksCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/PCIeDevice_v1.xml">
			<edmx:Include Namespace="PCIeDevice" />
				<edmx:Include Namespace="PCIeDevice.v1_13_0" />
		</edmx:Reference>
			<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/PCIeDeviceCollection_v1.xml">
		<edmx:Include Namespace="PCIeDeviceCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/CXLLogicalDevice_v1.xml">
			<edmx:Include Namespace="CXLLogicalDevice" />
				<edmx:Include Namespace="CXLLogicalDevice.v1_1_1" />
		</edmx:Reference>
			<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/CXLLogicalDeviceCollection_v1.xml">
		<edmx:Include Namespace="CXLLogicalDeviceCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Endpoint_v1.xml">
			<edmx:Include Namespace="Endpoint" />
				<edmx:Include Namespace="Endpoint.v1_8_1" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/EndpointCollection_v1.xml">
			<edmx:Include Namespace="EndpointCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Connection_v1.xml">
			<edmx:Include Namespace="Connection" />
				<edmx:Include Namespace="Connection.v1_3_1" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/ConnectionCollection_v1.xml">
			<edmx:Include Namespace="ConnectionCollection" />
		</edmx:Reference>
	</edmx:Edmx>`

	return redfishapi.Response(http.StatusOK, metadata), nil
}

// RedfishV1OdataGet -
func (cfm *CfmApiService) RedfishV1OdataGet(ctx context.Context) (redfishapi.ImplResponse, error) {

	resource := redfishapi.RedfishV1OdataGet200Response{
		// OdataContext: "/redfish/v1/odata",
	}

	resource.Value = append(resource.Value, redfishapi.RedfishV1OdataGet200ResponseValueInner{
		Kind: "Singleton",
		Name: "Service",
		Url:  "/redfish/v1",
	})

	resource.Value = append(resource.Value, redfishapi.RedfishV1OdataGet200ResponseValueInner{
		Kind: "Singleton",
		Name: "Chassis",
		Url:  "/redfish/v1/Chassis",
	})

	resource.Value = append(resource.Value, redfishapi.RedfishV1OdataGet200ResponseValueInner{
		Kind: "Singleton",
		Name: "Fabrics",
		Url:  "/redfish/v1/Fabrics",
	})

	resource.Value = append(resource.Value, redfishapi.RedfishV1OdataGet200ResponseValueInner{
		Kind: "Singleton",
		Name: "Systems",
		Url:  "/redfish/v1/Systems",
	})

	return redfishapi.Response(http.StatusOK, resource), nil
}

// RedfishV1SystemsComputerSystemIdGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdGet(ctx context.Context, computerSystemId string) (redfishapi.ImplResponse, error) {
	_, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.ComputerSystemV1220ComputerSystem{
		// OdataContext:            "",
		// OdataEtag:               "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId,
		OdataType: "#ComputerSystem.v1_22_0.ComputerSystem",
		// Actions:                 redfishapi.ComputerSystemV1220Actions{},
		// AssetTag:                new(string),
		// Bios:                    redfishapi.OdataV4IdRef{},
		// BiosVersion:             new(string),
		// Boot:                    redfishapi.ComputerSystemV1220Boot{},
		// BootProgress:            redfishapi.ComputerSystemV1220BootProgress{},
		// Certificates:            redfishapi.OdataV4IdRef{},
		// Composition:             redfishapi.ComputerSystemV1220Composition{},
		// Description:             "",
		// EthernetInterfaces:      redfishapi.OdataV4IdRef{},
		// FabricAdapters:          redfishapi.OdataV4IdRef{},
		// GraphicalConsole:        redfishapi.ComputerSystemV1220HostGraphicalConsole{},
		// GraphicsControllers:     redfishapi.OdataV4IdRef{},
		// HostName:                new(string),
		// HostWatchdogTimer:       redfishapi.ComputerSystemV1220WatchdogTimer{},
		// HostedServices:          redfishapi.ComputerSystemV1220HostedServices{},
		// HostingRoles:            []redfishapi.ComputerSystemV1220HostingRole{},
		Id: computerSystemId,
		// IdlePowerSaver: redfishapi.ComputerSystemV1220IdlePowerSaver{},
		// IndicatorLED:            "",
		// KeyManagement:           redfishapi.ComputerSystemV1220KeyManagement{},
		// LastResetTime:           time.Time{},
		// Links:                   redfishapi.ComputerSystemV1220Links{},
		// LocationIndicatorActive: new(bool),
		// LogServices:             redfishapi.OdataV4IdRef{},
		// Manufacturer:            new(string),
		// ManufacturingMode:       new(bool),
		// Measurements:            []redfishapi.SoftwareInventoryMeasurementBlock{},
		Memory: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/Memory", computerSystemId),
		},
		MemoryDomains: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains", computerSystemId),
		},
		// MemorySummary:           redfishapi.ComputerSystemV1220MemorySummary{},
		// Model:                   new(string),
		Name: computerSystemId,
		// NetworkInterfaces:       redfishapi.OdataV4IdRef{},
		// Oem:                     map[string]interface{}{},
		// OperatingSystem:         redfishapi.OdataV4IdRef{},
		// PCIeDevices:             []redfishapi.OdataV4IdRef{},
		// PCIeDevicesodataCount:   0,
		// PCIeFunctions:           []redfishapi.OdataV4IdRef{},
		// PCIeFunctionsodataCount: 0,
		// PartNumber:              new(string),
		// PowerCycleDelaySeconds:  new(float32),
		// PowerMode:               "",
		// PowerOffDelaySeconds:    new(float32),
		// PowerOnDelaySeconds:     new(float32),
		// PowerRestorePolicy:      "",
		// PowerState:              "",
		// ProcessorSummary:        redfishapi.ComputerSystemV1220ProcessorSummary{},
		// Processors:              redfishapi.OdataV4IdRef{},
		// Redundancy:              []redfishapi.RedundancyRedundancy{},
		// RedundancyodataCount:    0,
		// SKU:                     new(string),
		// SecureBoot:              redfishapi.OdataV4IdRef{},
		// SerialConsole:           redfishapi.ComputerSystemV1220HostSerialConsole{},
		// SerialNumber:            new(string),
		// SimpleStorage:           redfishapi.OdataV4IdRef{},
		// Status:                  redfishapi.ResourceStatus{},
		// Storage:                 redfishapi.OdataV4IdRef{},
		// SubModel:                new(string),
		// SystemType:              "",
		// TrustedModules:          []redfishapi.ComputerSystemV1220TrustedModules{},
		// USBControllers:          redfishapi.OdataV4IdRef{},
		// UUID:                    "",
		// VirtualMedia:            redfishapi.OdataV4IdRef{},
		// VirtualMediaConfig:      redfishapi.ComputerSystemV1220VirtualMediaConfig{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsGet(ctx context.Context, computerSystemId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by blade id
	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range bladeIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s", computerSystemId, member)})
	}

	return redfishapi.Response(200, redfishapi.MemoryDomainCollectionMemoryDomainCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains",
		OdataType: "#MemoryDomainCollection.MemoryDomainCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "MemoryDomain Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdGet(ctx context.Context, computerSystemId string, memoryDomainId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	allowsMemoryChunkCreation := true
	return redfishapi.Response(200, redfishapi.MemoryDomainV150MemoryDomain{
		// OdataContext:              "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId,
		OdataType: "#MemoryDomain.v1_5_0.MemoryDomain",
		// Actions:                   redfishapi.MemoryDomainV150Actions{},
		// AllowsBlockProvisioning:   new(bool),
		AllowsMemoryChunkCreation: &allowsMemoryChunkCreation,
		// AllowsMirroring:           new(bool),
		// AllowsSparing:             new(bool),
		// Description:               "",
		Id: memoryDomainId,
		// InterleavableMemorySets:   []redfishapi.MemoryDomainV150MemorySet{},
		// Links: redfishapi.MemoryDomainV150Links{},
		// MemoryChunkIncrementMiB:   new(int64),
		MemoryChunks: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks", computerSystemId, memoryDomainId),
		},
		// MemorySizeMiB:             new(int64),
		// MinMemoryChunkSizeMiB:     new(int64),
		Name: memoryDomainId,
		// Oem:                       map[string]interface{}{},
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksGet(ctx context.Context, computerSystemId string, memoryDomainId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by memory id
	memoryIds := blade.GetAllMemoryIds()
	sort.Strings(memoryIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range memoryIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks/%s", computerSystemId, memoryDomainId, member)})
	}

	return redfishapi.Response(200, redfishapi.MemoryChunksCollectionMemoryChunksCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId + "/MemoryChunks",
		OdataType: "#MemoryChunksCollection.MemoryChunksCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "MemoryChunk Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdDelete -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdDelete(ctx context.Context, computerSystemId string, memoryDomainId string, memoryChunksId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.FreeMemoryById(ctx, memoryChunksId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	memorySize := int64(memory.SizeMiB)

	return redfishapi.Response(200, redfishapi.MemoryChunksV161MemoryChunks{
		// OdataContext:              "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId + "/MemoryChunks/" + memoryChunksId,
		OdataType: "#MemoryChunks.V1_6_1.MemoryChunks",
		// Actions:                   redfishapi.MemoryChunksV161Actions{},
		// AddressRangeOffsetMiB:     new(int64),
		// AddressRangeType:          "",
		// Description:               "",
		// DisplayName:               new(string),
		Id: memoryChunksId,
		// InterleaveSets:            []redfishapi.MemoryChunksV161InterleaveSet{},
		// IsMirrorEnabled:           new(bool),
		// IsSpare:                   new(bool),
		// Links:                     redfishapi.MemoryChunksV161Links{},
		// MediaLocation:             "",
		MemoryChunkSizeMiB: &memorySize,
		Name:               memoryChunksId,
		// Oem:                       map[string]interface{}{},
		// RequestedOperationalState: "",
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdGet(ctx context.Context, computerSystemId string, memoryDomainId string, memoryChunksId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.GetMemoryById(ctx, memoryChunksId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memory.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	memorySize := int64(details.SizeMiB)

	return redfishapi.Response(200, redfishapi.MemoryChunksV161MemoryChunks{
		// OdataContext:              "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId + "/MemoryChunks/" + memoryChunksId,
		OdataType: "#MemoryChunks.V1_6_1.MemoryChunks",
		// Actions:                   redfishapi.MemoryChunksV161Actions{},
		// AddressRangeOffsetMiB:     new(int64),
		// AddressRangeType:          "",
		// Description:               "",
		// DisplayName:               new(string),
		Id: memoryChunksId,
		// InterleaveSets:            []redfishapi.MemoryChunksV161InterleaveSet{},
		// IsMirrorEnabled:           new(bool),
		// IsSpare:                   new(bool),
		// Links:                     redfishapi.MemoryChunksV161Links{},
		// MediaLocation:             "",
		MemoryChunkSizeMiB: &memorySize,
		Name:               memoryChunksId,
		// Oem:                       map[string]interface{}{},
		// RequestedOperationalState: "",
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksPost -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksPost(ctx context.Context, computerSystemId string, memoryDomainId string, memoryChunksV161MemoryChunks redfishapi.MemoryChunksV161MemoryChunks) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// TODO: move this logic into manager.go
	resourceIds := []string{}
	blocksNeededPerChannel := int32(*memoryChunksV161MemoryChunks.MemoryChunkSizeMiB) / blade.ResourceSizeMib / int32(len(memoryChunksV161MemoryChunks.InterleaveSets))

	for _, dpInfo := range memoryChunksV161MemoryChunks.InterleaveSets {
		if dpInfo.Memory.OdataId == "" {
			return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("link to memory is required")), nil
		}
		if dpInfo.OffsetMiB == nil {
			return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("OffsetMiB field is required")), nil
		}

		memoryIdSplit := strings.Split(dpInfo.Memory.OdataId, "dp")
		portId, _ := strconv.Atoi(memoryIdSplit[1])

		if fmt.Sprintf("/redfish/v1/Systems/%s/Memory/%sdp%d", computerSystemId, memoryDomainId, portId) != dpInfo.Memory.OdataId {
			return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("memory (%s) is invalid", dpInfo.Memory.OdataId)), nil
		}
		if int32(*dpInfo.OffsetMiB)%blade.ResourceSizeMib != 0 {
			return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("OffsetMiB (%d) is aligned to resource block size", dpInfo.OffsetMiB)), nil
		}
		for resourceId, resource := range blade.Resources {
			if portId == int(resource.GetChannelId()) {
				if int32(*dpInfo.OffsetMiB)/blade.ResourceSizeMib <= resource.GetChannelResourceIndex() &&
					int32(*dpInfo.OffsetMiB)/blade.ResourceSizeMib+blocksNeededPerChannel > resource.GetChannelResourceIndex() {
					if resource.GetCompositionState() == backend.RESOURCE_STATE_UNUSED {
						resourceIds = append(resourceIds, resourceId)
					} else {
						return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("resource (%s) is not available", resourceId)), nil
					}
				}

			}
		}

	}

	if int32(len(resourceIds)) != int32(*memoryChunksV161MemoryChunks.MemoryChunkSizeMiB)/blade.ResourceSizeMib {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("cannot find request memory resoureces")), nil
	}

	memory, err := blade.ComposeMemoryByResource(ctx, "", resourceIds)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	memorySize := int64(memory.SizeMiB)
	memoryChunksId := memory.Id

	return redfishapi.Response(201, redfishapi.MemoryChunksV161MemoryChunks{
		// OdataContext:              "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId + "/MemoryChunks/" + memoryChunksId,
		OdataType: "#MemoryChunks.V1_6_1.MemoryChunks",
		// Actions:                   redfishapi.MemoryChunksV161Actions{},
		// AddressRangeOffsetMiB:     new(int64),
		// AddressRangeType:          "",
		// Description:               "",
		// DisplayName:               new(string),
		Id: memoryChunksId,
		// InterleaveSets:            []redfishapi.MemoryChunksV161InterleaveSet{},
		// IsMirrorEnabled:           new(bool),
		// IsSpare:                   new(bool),
		// Links:                     redfishapi.MemoryChunksV161Links{},
		// MediaLocation:             "",
		MemoryChunkSizeMiB: &memorySize,
		Name:               memoryChunksId,
		// Oem:                       map[string]interface{}{},
		// RequestedOperationalState: "",
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryGet(ctx context.Context, computerSystemId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by blade id
	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)

	members := []redfishapi.OdataV4IdRef{}
	for _, bladeId := range bladeIds {
		blade, _ := appliance.GetBladeById(ctx, bladeId)

		for portId := 0; portId < int(blade.NumResourceChannels); portId++ {
			members = append(members, redfishapi.OdataV4IdRef{
				OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/Memory/%s", computerSystemId, fmt.Sprintf("%sdp%d", bladeId, portId))})
		}
	}

	return redfishapi.Response(200, redfishapi.MemoryCollectionMemoryCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/Memory",
		OdataType: "#MemoryCollection.MemoryCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Memory Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryMemoryIdGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryMemoryIdGet(ctx context.Context, computerSystemId string, memoryId string) (redfishapi.ImplResponse, error) {

	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memoryIdSplit := strings.Split(memoryId, "dp")
	bladeId := memoryIdSplit[0]
	portId, _ := strconv.Atoi(memoryIdSplit[1])
	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	if int32(portId) >= blade.NumResourceChannels {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("port Id (%d) is not found", portId)), nil
	}

	capacityMiB := int64(blade.ResourceSizeMib/blade.NumResourceChannels) * int64(len(blade.Resources))

	return redfishapi.Response(200, redfishapi.MemoryV1190Memory{
		// OdataContext:                            "",
		// OdataEtag:                               "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/Memory/" + memoryId,
		OdataType: "#Memory.v1_19_0.Memory",
		// Actions:                                 redfishapi.MemoryV1190Actions{},
		// AllocationAlignmentMiB:                  new(int64),
		// AllocationIncrementMiB:                  new(int64),
		// AllowedSpeedsMHz:                        []int64{},
		// Assembly:                                redfishapi.OdataV4IdRef{},
		// BaseModuleType:                          "",
		// BusWidthBits:                            new(int64),
		// CXL:                                     redfishapi.MemoryV1190Cxl{},
		// CacheSizeMiB:                            new(int64),
		CapacityMiB: &capacityMiB,
		// Certificates:                            redfishapi.OdataV4IdRef{},
		// ConfigurationLocked:                     new(bool),
		// DataWidthBits:                           new(int64),
		// Description:                             "",
		// DeviceID:                                new(string),
		// DeviceLocator:                           new(string),
		// Enabled:                                 false,
		// EnvironmentMetrics:                      redfishapi.OdataV4IdRef{},
		// ErrorCorrection:                         "",
		// FirmwareApiVersion:                      new(string),
		// FirmwareRevision:                        new(string),
		// FunctionClasses:                         []string{},
		// HealthData:                              redfishapi.MemoryV1190HealthData{},
		Id: memoryId,
		// IsRankSpareEnabled:                      new(bool),
		// IsSpareDeviceEnabled:                    new(bool),
		// Links:                                   redfishapi.MemoryV1190Links{},
		// Location:                                redfishapi.ResourceLocation{},
		// LocationIndicatorActive:                 new(bool),
		// Log:                                     redfishapi.OdataV4IdRef{},
		// LogicalSizeMiB:                          new(int64),
		// Manufacturer:                            new(string),
		// MaxTDPMilliWatts:                        []int64{},
		// Measurements:                            []redfishapi.SoftwareInventoryMeasurementBlock{},
		// MemoryDeviceType:                        "",
		// MemoryLocation:                          redfishapi.MemoryV1190MemoryLocation{},
		// MemoryMedia:                             []redfishapi.MemoryV1190MemoryMedia{},
		// MemorySubsystemControllerManufacturerID: new(string),
		// MemorySubsystemControllerProductID:      new(string),
		// MemoryType:                              "",
		// Metrics:                                 redfishapi.OdataV4IdRef{},
		// Model:                                   new(string),
		// ModuleManufacturerID:                    new(string),
		// ModuleProductID:                         new(string),
		Name: memoryId,
		// NonVolatileSizeLimitMiB:                 0,
		// NonVolatileSizeMiB:                      new(int64),
		// Oem:                                     map[string]interface{}{},
		// OperatingMemoryModes:                    []redfishapi.MemoryV1190OperatingMemoryModes{},
		// OperatingSpeedMhz:                       new(int64),
		// OperatingSpeedRangeMHz:                  redfishapi.ControlControlRangeExcerpt{},
		// PartNumber:                              new(string),
		// PersistentRegionNumberLimit:             new(int64),
		// PersistentRegionSizeLimitMiB:            new(int64),
		// PersistentRegionSizeMaxMiB:              new(int64),
		// PoisonListMaxMediaErrorRecords:          0,
		// PowerManagementPolicy:                   redfishapi.MemoryV1190PowerManagementPolicy{},
		// RankCount:                               new(int64),
		// Regions:                                 []redfishapi.MemoryV1190RegionSet{},
		// SecurityCapabilities:                    redfishapi.MemoryV1190SecurityCapabilities{},
		// SecurityState:                           "",
		// SecurityStates:                          redfishapi.MemoryV1190SecurityStateInfo{},
		// SerialNumber:                            new(string),
		// SpareDeviceCount:                        new(int64),
		// SparePartNumber:                         new(string),
		// Status:                                  redfishapi.ResourceStatus{},
		// SubsystemDeviceID:                       new(string),
		// SubsystemVendorID:                       new(string),
		// VendorID:                                new(string),
		// VolatileRegionNumberLimit:               new(int64),
		// VolatileRegionSizeLimitMiB:              new(int64),
		// VolatileRegionSizeMaxMiB:                new(int64),
		// VolatileSizeLimitMiB:                    0,
		// VolatileSizeMiB:                         new(int64),
	}), nil
}

// RedfishV1SystemsGet -
func (cfm *CfmApiService) RedfishV1SystemsGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	// order returned uris by appliance id
	applianceIds := manager.GetAllApplianceIds()
	sort.Strings(applianceIds)

	appliances := manager.GetAppliances(ctx)
	members := []redfishapi.OdataV4IdRef{}
	for member := range appliances {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s", member)})
	}

	return redfishapi.Response(200, redfishapi.ComputerSystemCollectionComputerSystemCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Systems",
		OdataType: "#ComputerSystemCollection.ComputerSystemCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "ComputerSystem Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

func formatRedfishErrorResp(ctx context.Context, re *common.RequestError) (redfishapi.ImplResponse, error) {
	status := redfishapi.RedfishError{
		Error: redfishapi.RedfishErrorError{
			MessageExtendedInfo: []redfishapi.MessageV120Message{{
				Message: re.Err.Error(),
				Oem:     map[string]interface{}{"Uri": common.GetContextString(ctx, common.KeyUri)},
			}},
			Code:    strconv.Itoa(re.StatusCode.HttpStatusCode()),
			Message: re.StatusCode.String(),
		},
	}
	return redfishapi.Response(re.StatusCode.HttpStatusCode(), status), nil
}

// RedfishV1AccountServiceAccountsGet -
func (cfm *CfmApiService) RedfishV1AccountServiceAccountsGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceAccountsGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, ManagerAccountCollectionManagerAccountCollection{}) or use other options such as http.Ok ...
	// return Response(200, ManagerAccountCollectionManagerAccountCollection{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceAccountsGet method not implemented")
}

// RedfishV1AccountServiceAccountsManagerAccountIdDelete -
func (cfm *CfmApiService) RedfishV1AccountServiceAccountsManagerAccountIdDelete(ctx context.Context, managerAccountId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceAccountsManagerAccountIdDelete with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, ManagerAccountV1120ManagerAccount{}) or use other options such as http.Ok ...
	// return Response(200, ManagerAccountV1120ManagerAccount{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceAccountsManagerAccountIdDelete method not implemented")
}

// RedfishV1AccountServiceAccountsManagerAccountIdGet -
func (cfm *CfmApiService) RedfishV1AccountServiceAccountsManagerAccountIdGet(ctx context.Context, managerAccountId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceAccountsManagerAccountIdGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, ManagerAccountV1120ManagerAccount{}) or use other options such as http.Ok ...
	// return Response(200, ManagerAccountV1120ManagerAccount{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceAccountsManagerAccountIdGet method not implemented")
}

// RedfishV1AccountServiceAccountsManagerAccountIdPatch -
func (cfm *CfmApiService) RedfishV1AccountServiceAccountsManagerAccountIdPatch(ctx context.Context, managerAccountId string, managerAccountV1120ManagerAccount redfishapi.ManagerAccountV1120ManagerAccount) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceAccountsManagerAccountIdPatch with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, ManagerAccountV1120ManagerAccount{}) or use other options such as http.Ok ...
	// return Response(200, ManagerAccountV1120ManagerAccount{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceAccountsManagerAccountIdPatch method not implemented")
}

// RedfishV1AccountServiceAccountsManagerAccountIdPut -
func (cfm *CfmApiService) RedfishV1AccountServiceAccountsManagerAccountIdPut(ctx context.Context, managerAccountId string, managerAccountV1120ManagerAccount redfishapi.ManagerAccountV1120ManagerAccount) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceAccountsManagerAccountIdPut with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, ManagerAccountV1120ManagerAccount{}) or use other options such as http.Ok ...
	// return Response(200, ManagerAccountV1120ManagerAccount{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceAccountsManagerAccountIdPut method not implemented")
}

// RedfishV1AccountServiceAccountsPost -
func (cfm *CfmApiService) RedfishV1AccountServiceAccountsPost(ctx context.Context, managerAccountV1120ManagerAccount redfishapi.ManagerAccountV1120ManagerAccount) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceAccountsPost with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(201, ManagerAccountV1120ManagerAccount{}) or use other options such as http.Ok ...
	// return Response(201, ManagerAccountV1120ManagerAccount{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceAccountsPost method not implemented")
}

// RedfishV1AccountServiceGet -
func (cfm *CfmApiService) RedfishV1AccountServiceGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, AccountServiceV1150AccountService{}) or use other options such as http.Ok ...
	// return Response(200, AccountServiceV1150AccountService{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceGet method not implemented")
}

// RedfishV1AccountServicePatch -
func (cfm *CfmApiService) RedfishV1AccountServicePatch(ctx context.Context, accountServiceV1150AccountService redfishapi.AccountServiceV1150AccountService) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServicePatch with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, AccountServiceV1150AccountService{}) or use other options such as http.Ok ...
	// return Response(200, AccountServiceV1150AccountService{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServicePatch method not implemented")
}

// RedfishV1AccountServicePut -
func (cfm *CfmApiService) RedfishV1AccountServicePut(ctx context.Context, accountServiceV1150AccountService redfishapi.AccountServiceV1150AccountService) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServicePut with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, AccountServiceV1150AccountService{}) or use other options such as http.Ok ...
	// return Response(200, AccountServiceV1150AccountService{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServicePut method not implemented")
}

// RedfishV1AccountServiceRolesGet -
func (cfm *CfmApiService) RedfishV1AccountServiceRolesGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceRolesGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, RoleCollectionRoleCollection{}) or use other options such as http.Ok ...
	// return Response(200, RoleCollectionRoleCollection{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceRolesGet method not implemented")
}

// RedfishV1AccountServiceRolesPost -
func (cfm *CfmApiService) RedfishV1AccountServiceRolesPost(ctx context.Context, roleV131Role redfishapi.RoleV131Role) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceRolesPost with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(201, RoleV131Role{}) or use other options such as http.Ok ...
	// return Response(201, RoleV131Role{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceRolesPost method not implemented")
}

// RedfishV1AccountServiceRolesRoleIdDelete -
func (cfm *CfmApiService) RedfishV1AccountServiceRolesRoleIdDelete(ctx context.Context, roleId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceRolesRoleIdDelete with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, RoleV131Role{}) or use other options such as http.Ok ...
	// return Response(200, RoleV131Role{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceRolesRoleIdDelete method not implemented")
}

// RedfishV1AccountServiceRolesRoleIdGet -
func (cfm *CfmApiService) RedfishV1AccountServiceRolesRoleIdGet(ctx context.Context, roleId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceRolesRoleIdGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, RoleV131Role{}) or use other options such as http.Ok ...
	// return Response(200, RoleV131Role{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceRolesRoleIdGet method not implemented")
}

// RedfishV1AccountServiceRolesRoleIdPatch -
func (cfm *CfmApiService) RedfishV1AccountServiceRolesRoleIdPatch(ctx context.Context, roleId string, roleV131Role redfishapi.RoleV131Role) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceRolesRoleIdPatch with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, RoleV131Role{}) or use other options such as http.Ok ...
	// return Response(200, RoleV131Role{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceRolesRoleIdPatch method not implemented")
}

// RedfishV1AccountServiceRolesRoleIdPut -
func (cfm *CfmApiService) RedfishV1AccountServiceRolesRoleIdPut(ctx context.Context, roleId string, roleV131Role redfishapi.RoleV131Role) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1AccountServiceRolesRoleIdPut with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, RoleV131Role{}) or use other options such as http.Ok ...
	// return Response(200, RoleV131Role{}), nil

	// TODO: Uncomment the next line to return response Response(202, TaskV173Task{}) or use other options such as http.Ok ...
	// return Response(202, TaskV173Task{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1AccountServiceRolesRoleIdPut method not implemented")
}

// RedfishV1ChassisChassisIdMemoryGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryGet(ctx context.Context, chassisId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1ChassisChassisIdMemoryGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, MemoryCollectionMemoryCollection{}) or use other options such as http.Ok ...
	// return Response(200, MemoryCollectionMemoryCollection{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1ChassisChassisIdMemoryGet method not implemented")
}

// RedfishV1ChassisChassisIdMemoryMemoryIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryMemoryIdGet(ctx context.Context, chassisId string, memoryId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1ChassisChassisIdMemoryMemoryIdGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, MemoryV1190Memory{}) or use other options such as http.Ok ...
	// return Response(200, MemoryV1190Memory{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1ChassisChassisIdMemoryMemoryIdGet method not implemented")
}

// RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdPCIeFunctionsGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdPCIeFunctionsGet(ctx context.Context, chassisId string, pCIeDeviceId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdPCIeFunctionsGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, PcieFunctionCollectionPcieFunctionCollection{}) or use other options such as http.Ok ...
	// return Response(200, PcieFunctionCollectionPcieFunctionCollection{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdPCIeFunctionsGet method not implemented")
}

// RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdPCIeFunctionsPCIeFunctionIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdPCIeFunctionsPCIeFunctionIdGet(ctx context.Context, chassisId string, pCIeDeviceId string, pCIeFunctionId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdPCIeFunctionsPCIeFunctionIdGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, PcieFunctionV151PcieFunction{}) or use other options such as http.Ok ...
	// return Response(200, PcieFunctionV151PcieFunction{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdPCIeFunctionsPCIeFunctionIdGet method not implemented")
}

// RedfishV1SessionServiceGet -
func (cfm *CfmApiService) RedfishV1SessionServiceGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1SessionServiceGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Object{}) or use other options such as http.Ok ...
	// return Response(200, Object{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1SessionServiceGet method not implemented")
}

// RedfishV1SessionServicePatch -
func (cfm *CfmApiService) RedfishV1SessionServicePatch(ctx context.Context, sessionServiceV118SessionService redfishapi.SessionServiceV118SessionService) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1SessionServicePatch with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Object{}) or use other options such as http.Ok ...
	// return Response(200, Object{}), nil

	// TODO: Uncomment the next line to return response Response(202, Object{}) or use other options such as http.Ok ...
	// return Response(202, Object{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1SessionServicePatch method not implemented")
}

// RedfishV1SessionServicePut -
func (cfm *CfmApiService) RedfishV1SessionServicePut(ctx context.Context, sessionServiceV118SessionService redfishapi.SessionServiceV118SessionService) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1SessionServicePut with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Object{}) or use other options such as http.Ok ...
	// return Response(200, Object{}), nil

	// TODO: Uncomment the next line to return response Response(202, Object{}) or use other options such as http.Ok ...
	// return Response(202, Object{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1SessionServicePut method not implemented")
}

// RedfishV1SessionServiceSessionsGet -
func (cfm *CfmApiService) RedfishV1SessionServiceSessionsGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1SessionServiceSessionsGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Object{}) or use other options such as http.Ok ...
	// return Response(200, Object{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1SessionServiceSessionsGet method not implemented")
}

// RedfishV1SessionServiceSessionsPost -
func (cfm *CfmApiService) RedfishV1SessionServiceSessionsPost(ctx context.Context, sessionV171Session redfishapi.SessionV171Session) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1SessionServiceSessionsPost with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(201, Object{}) or use other options such as http.Ok ...
	// return Response(201, Object{}), nil

	// TODO: Uncomment the next line to return response Response(202, Object{}) or use other options such as http.Ok ...
	// return Response(202, Object{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1SessionServiceSessionsPost method not implemented")
}

// RedfishV1SessionServiceSessionsSessionIdDelete -
func (cfm *CfmApiService) RedfishV1SessionServiceSessionsSessionIdDelete(ctx context.Context, sessionId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1SessionServiceSessionsSessionIdDelete with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Object{}) or use other options such as http.Ok ...
	// return Response(200, Object{}), nil

	// TODO: Uncomment the next line to return response Response(202, Object{}) or use other options such as http.Ok ...
	// return Response(202, Object{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1SessionServiceSessionsSessionIdDelete method not implemented")
}

// RedfishV1SessionServiceSessionsSessionIdGet -
func (cfm *CfmApiService) RedfishV1SessionServiceSessionsSessionIdGet(ctx context.Context, sessionId string) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1SessionServiceSessionsSessionIdGet with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Object{}) or use other options such as http.Ok ...
	// return Response(200, Object{}), nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1SessionServiceSessionsSessionIdGet method not implemented")
}

// RedfishV1SystemsComputerSystemIdActionsComputerSystemResetPost -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdActionsComputerSystemResetPost(ctx context.Context, computerSystemId string, computerSystemV1220ResetRequestBody redfishapi.ComputerSystemV1220ResetRequestBody) (redfishapi.ImplResponse, error) {
	// TODO - update RedfishV1SystemsComputerSystemIdActionsComputerSystemResetPost with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, RedfishError{}) or use other options such as http.Ok ...
	// return Response(200, RedfishError{}), nil

	// TODO: Uncomment the next line to return response Response(201, RedfishError{}) or use other options such as http.Ok ...
	// return Response(201, RedfishError{}), nil

	// TODO: Uncomment the next line to return response Response(202, Object{}) or use other options such as http.Ok ...
	// return Response(202, Object{}), nil

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(0, RedfishError{}) or use other options such as http.Ok ...
	// return Response(0, RedfishError{}), nil

	return redfishapi.Response(http.StatusNotImplemented, nil), errors.New("RedfishV1SystemsComputerSystemIdActionsComputerSystemResetPost method not implemented")
}
