/*
Copyright (c) 2024 Seagate Technology LLC and/or its Affiliates

Composer and Fabric Manager Service OpenAPI

This API allows users to interact through the CFM Service with CXL Hosts and Memory Appliances. The main purpose of this interface is to allow the retrieval of information and the creation and mapping of memory from a Memory Appliance to a CXL host.

API version: 1.7.0
Generated by: OpenAPI Generator (https://openapi-generator.tech)
*/

package api

import (
	"context"
	"fmt"
	"net/http"
	"slices"
	"sort"
	"strconv"
	"strings"

	"cfm/pkg/backend"
	"cfm/pkg/common"
	"cfm/pkg/manager"
	"cfm/pkg/redfishapi"
)

// NewRedfishApiService creates a default api service
func NewRedfishApiService(version string) redfishapi.DefaultAPIServicer {
	return &CfmApiService{Version: version}
}

// RedfishGet -
func (cfm *CfmApiService) RedfishGet(ctx context.Context) (redfishapi.ImplResponse, error) {

	version := CfmVersionType{
		Version: "/redfish/v1",
	}

	return redfishapi.Response(http.StatusOK, version), nil
}

// RedfishV1ChassisChassisIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdGet(ctx context.Context, chassisId string) (redfishapi.ImplResponse, error) {
	_, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.ChassisV1250Chassis{
		// OdataContext: "/redfish/v1/$metadata#Chassis.Chassis",
		// OdataEtag:                    "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId,
		OdataType: "#Chassis_v1_25_0_Chassis",
		// Actions:                      redfishapi.ChassisV1250Actions{},
		// Assembly:                     redfishapi.OdataV4IdRef{},
		// AssetTag:                     new(string),
		// Certificates:                 redfishapi.OdataV4IdRef{},
		// ChassisType:                  "",
		// Controls:                     redfishapi.OdataV4IdRef{},
		// DepthMm:                      new(float32),
		// Description:                  "",
		// Doors:                        redfishapi.ChassisV1250Doors{},
		// Drives:                       redfishapi.OdataV4IdRef{},
		// ElectricalSourceManagerURIs:  []*string{},
		// ElectricalSourceNames:        []*string{},
		// EnvironmentMetrics:           redfishapi.OdataV4IdRef{},
		// EnvironmentalClass:           "",
		// FabricAdapters:               redfishapi.OdataV4IdRef{},
		// HeatingCoolingEquipmentNames: []*string{},
		// HeatingCoolingManagerURIs:    []*string{},
		// HeightMm:                     new(float32),
		// HotPluggable:                 new(bool),
		Id: chassisId,
		// IndicatorLED:                 "",
		// Links:                        redfishapi.ChassisV1250Links{},
		// Location:                     redfishapi.ResourceLocation{},
		// LocationIndicatorActive:      new(bool),
		// LogServices:                  redfishapi.OdataV4IdRef{},
		// Manufacturer:                 new(string),
		// MaxPowerWatts:                new(float32),
		// Measurements:                 []redfishapi.SoftwareInventoryMeasurementBlock{},
		// MediaControllers:             redfishapi.OdataV4IdRef{},
		// Memory: redfishapi.OdataV4IdRef{
		// 	OdataId: "/redfish/v1/Chassis/" + chassisId + "/Memory",
		// },
		MemoryDomains: redfishapi.OdataV4IdRef{
			OdataId: "/redfish/v1/Chassis/" + chassisId + "/MemoryDomains",
		},
		// MinPowerWatts:   new(float32),
		// Model:           new(string),
		Name: chassisId,
		// NetworkAdapters: redfishapi.OdataV4IdRef{},
		// Oem:             map[string]interface{}{},
		PCIeDevices: redfishapi.OdataV4IdRef{
			OdataId: "/redfish/v1/Chassis/" + chassisId + "/PCIeDevices",
		},
		// PCIeSlots:              redfishapi.OdataV4IdRef{},
		// PartNumber:             new(string),
		// PhysicalSecurity:       redfishapi.ChassisV1250PhysicalSecurity{},
		// Power:                  redfishapi.OdataV4IdRef{},
		// PowerState:             "",
		// PowerSubsystem:         redfishapi.OdataV4IdRef{},
		// PoweredByParent:        new(bool),
		// Processors:             redfishapi.OdataV4IdRef{},
		// Replaceable:            new(bool),
		// SKU:                    new(string),
		// Sensors:                redfishapi.OdataV4IdRef{},
		// SerialNumber:           new(string),
		// SparePartNumber:        new(string),
		// Status:                 redfishapi.ResourceStatus{},
		// Thermal:                redfishapi.OdataV4IdRef{},
		// ThermalDirection:       "",
		// ThermalManagedByParent: new(bool),
		// ThermalSubsystem:       redfishapi.OdataV4IdRef{},
		// TrustedComponents:      redfishapi.OdataV4IdRef{},
		// UUID:                   "",
		// Version:                new(string),
		// WeightKg:               new(float32),
		// WidthMm:                new(float32),
	}), nil

}

// RedfishV1ChassisChassisIdMemoryDomainsGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryDomainsGet(ctx context.Context, chassisId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	domains := host.GetRedfishMemoryDomains(ctx)
	sort.Strings(domains)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range domains {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s", chassisId, member)})
	}

	return redfishapi.Response(200, redfishapi.MemoryDomainCollectionMemoryDomainCollection{
		// OdataContext: "#MemoryDomainCollection.MemoryDomainCollection",
		// OdataEtag:         "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/MemoryDomains",
		OdataType: "#MemoryDomainCollection.MemoryDomainCollection",
		// Description:       "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "MemoryDomain Collection",
		// Oem:                  map[string]interface{}{},
	}), nil

}

// RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdGet(ctx context.Context, chassisId string, memoryDomainId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = host.GetMemoryDomainAllMemoryIds(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// memory chunks
	return redfishapi.Response(200, redfishapi.MemoryDomainV150MemoryDomain{
		// OdataContext: "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/MemoryDomains/" + memoryDomainId,
		OdataType: "#MemoryDomain.v1_5_0.MemoryDomain",
		// Actions:                   redfishapi.MemoryDomainV150Actions{},
		// AllowsBlockProvisioning:   new(bool),
		// AllowsMemoryChunkCreation: new(bool),
		// AllowsMirroring:           new(bool),
		// AllowsSparing:             new(bool),
		// Description:               "",
		Id: memoryDomainId,
		// InterleavableMemorySets:   []redfishapi.MemoryDomainV150MemorySet{},
		// Links:                     redfishapi.MemoryDomainV150Links{},
		// MemoryChunkIncrementMiB:   new(int64),
		MemoryChunks: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s/MemoryChunks", chassisId, memoryDomainId),
		},
		// MemorySizeMiB:             new(int64),
		// MinMemoryChunkSizeMiB:     new(int64),
		Name: "Memory Domain",
		// Oem:                       map[string]interface{}{},
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdMemoryChunksGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdMemoryChunksGet(ctx context.Context, chassisId string, memoryDomainId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := host.GetMemoryDomainAllMemoryIds(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by memory id
	sort.Strings(memory)

	members := []redfishapi.OdataV4IdRef{}
	for _, member := range memory {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s/MemoryChunks/%s", chassisId, memoryDomainId, member)})
	}

	return redfishapi.Response(200, redfishapi.MemoryChunksCollectionMemoryChunksCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s/MemoryChunks", chassisId, memoryDomainId),
		OdataType: "#MemoryChunksCollection.MemoryChunksCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "",
		// Oem:                  map[string]interface{}{},
	}), nil

}

// RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdGet(ctx context.Context, chassisId string, memoryDomainId string, memoryChunksId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memorydomain, err := host.GetMemoryDomainAllMemoryIds(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	if !slices.Contains(memorydomain, memoryChunksId) {
		return redfishapi.Response(http.StatusNotFound, fmt.Errorf("memory chunk id (%s) does not exist", memoryChunksId)), nil
	}

	memory, err := host.GetMemoryById(ctx, memoryChunksId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memory.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	sizeMiB := int64(details.SizeMiB)
	return redfishapi.Response(200, redfishapi.MemoryChunksV161MemoryChunks{
		// OdataContext: "",
		// OdataEtag:                 "",
		OdataId:   fmt.Sprintf("/redfish/v1/Chassis/%s/MemoryDomains/%s/MemoryChunks/%s", chassisId, memoryDomainId, memoryChunksId),
		OdataType: "#MemoryChunks.V1_6_1.MemoryChunks",
		// Actions:                   redfishapi.MemoryChunksV161Actions{},
		// AddressRangeOffsetMiB:     new(int64),
		// AddressRangeType:          "",
		// Description:               "",
		// DisplayName:               new(string),
		Id: memoryChunksId,
		// InterleaveSets:            []redfishapi.MemoryChunksV161InterleaveSet{},
		// IsMirrorEnabled:           new(bool),
		// IsSpare:                   new(bool),
		// Links:                     redfishapi.MemoryChunksV161Links{},
		// MediaLocation:             "",
		MemoryChunkSizeMiB: &sizeMiB,
		Name:               memoryChunksId,
		// Oem:                       map[string]interface{}{},
		// RequestedOperationalState: "",
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1ChassisChassisIdPCIeDevicesGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesGet(ctx context.Context, chassisId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by memory device id
	memdevIds := host.GetAllMemoryDeviceIds()
	sort.Strings(memdevIds)

	members := []redfishapi.OdataV4IdRef{}
	for _, member := range memdevIds {
		memdevBade := strings.Split(member, ".")[0]
		pcieDevId := memdevBade[6:]
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/PCIeDevices/%s", chassisId, pcieDevId)})
	}

	return redfishapi.Response(200, redfishapi.PcieDeviceCollectionPcieDeviceCollection{
		// OdataContext: "/redfish/v1/$metadata#PCIeDeviceCollection.PCIeDeviceCollection",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/PCIeDevices",
		OdataType: "#PCIeDeviceCollection.PCIeDeviceCollection",
		// Description:       "PCIeDevice Collection",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "PCIeDevice Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdCXLLogicalDevicesCXLLogicalDeviceIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdCXLLogicalDevicesCXLLogicalDeviceIdGet(ctx context.Context, chassisId string, pCIeDeviceId string, cXLLogicalDeviceId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memdev, err := host.GetMemoryDeviceById(ctx, fmt.Sprintf("memdev%s.0", pCIeDeviceId))
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	if cXLLogicalDeviceId != memdev.LogicalDeviceId {
		return redfishapi.Response(http.StatusNotFound, fmt.Errorf("cxlLogicalDevice id (%s) does not exist", cXLLogicalDeviceId)), nil
	}

	details, err := memdev.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	return redfishapi.Response(200, redfishapi.CxlLogicalDeviceV111CxlLogicalDevice{
		// OdataContext:             "",
		// OdataEtag:                "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/PCIeDevices/" + pCIeDeviceId + "/CXLLogicalDevices/" + cXLLogicalDeviceId,
		OdataType: "#CXLLogicalDevice.v1_1_1.CXLLogicalDevice",
		// Actions:                  redfishapi.CxlLogicalDeviceV111Actions{},
		// Description:              "",
		Id:          cXLLogicalDeviceId,
		Identifiers: []redfishapi.ResourceIdentifier{},
		// Links:                    redfishapi.CxlLogicalDeviceV111Links{},
		// Log:                      redfishapi.OdataV4IdRef{},
		// MemoryRegions:            redfishapi.OdataV4IdRef{},
		MemorySizeMiB: int64(details.MemorySizeMiB),
		Name:          cXLLogicalDeviceId,
		// Oem:                      map[string]interface{}{},
		// QoS:                      redfishapi.CxlLogicalDeviceV111QoS{},
		// QoSTelemetryCapabilities: redfishapi.CxlLogicalDeviceV111QoSTelemetryCapabilities{},
		// SemanticsSupported:       []redfishapi.CxlLogicalDeviceV111CxlSemantic{},
		// Status:                   redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdCXLLogicalDevicesGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdCXLLogicalDevicesGet(ctx context.Context, chassisId string, pCIeDeviceId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memdev, err := host.GetMemoryDeviceById(ctx, fmt.Sprintf("memdev%s.0", pCIeDeviceId))
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	members := []redfishapi.OdataV4IdRef{}
	members = append(members, redfishapi.OdataV4IdRef{
		OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/PCIeDevices/%s/CXLLogicalDevices/%s", chassisId, memdev.PhysicalDeviceId, memdev.LogicalDeviceId)})

	return redfishapi.Response(200, redfishapi.CxlLogicalDeviceCollectionCxlLogicalDeviceCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   fmt.Sprintf("/redfish/v1/Chassis/%s/PCIeDevices/%s/CXLLogicalDevices", chassisId, pCIeDeviceId),
		OdataType: "#CXLLogicalDeviceCollection.CXLLogicalDeviceCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "CXL Logical Device Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdGet -
func (cfm *CfmApiService) RedfishV1ChassisChassisIdPCIeDevicesPCIeDeviceIdGet(ctx context.Context, chassisId string, pCIeDeviceId string) (redfishapi.ImplResponse, error) {
	host, err := manager.GetHostById(ctx, chassisId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = host.GetMemoryDeviceById(ctx, fmt.Sprintf("memdev%s.0", pCIeDeviceId))
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.PcieDeviceV1130PcieDevice{
		// OdataContext:            "",
		// OdataEtag:               "",
		OdataId:   "/redfish/v1/Chassis/" + chassisId + "/PCIeDevices/" + pCIeDeviceId,
		OdataType: "#PCIeDevice.v1_13_0.PCIeDevice",
		// Actions:                 redfishapi.PcieDeviceV1130Actions{},
		// Assembly:                redfishapi.OdataV4IdRef{},
		// AssetTag:                new(string),
		// CXLDevice:               redfishapi.PcieDeviceV1130CxlDevice{},
		CXLLogicalDevices: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s/PCIeDevices/%s/CXLLogicalDevices", chassisId, pCIeDeviceId),
		},
		// Description:             "",
		// DeviceType:              "",
		// EnvironmentMetrics:      redfishapi.OdataV4IdRef{},
		// FirmwareVersion:         new(string),
		Id: pCIeDeviceId,
		// Links:                   redfishapi.PcieDeviceV1130Links{},
		// LocationIndicatorActive: new(bool),
		// Manufacturer:            new(string),
		// Model:                   new(string),
		Name: pCIeDeviceId,
		// Oem:                     map[string]interface{}{},
		// PCIeFunctions:           redfishapi.OdataV4IdRef{},
		// PCIeInterface:           redfishapi.PcieDeviceV1130PcieInterface{},
		// PartNumber:              new(string),
		// ReadyToRemove:           new(bool),
		// SKU:                     new(string),
		// SerialNumber:            new(string),
		// Slot:                    redfishapi.PcieDeviceV1130Slot{},
		// SparePartNumber:         new(string),
		// StagedVersion:           "",
		// Status:                  redfishapi.ResourceStatus{},
		// UUID:                    "",
	}), nil
}

// RedfishV1ChassisGet -
func (cfm *CfmApiService) RedfishV1ChassisGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	hostIds := manager.GetAllHostIds()
	sort.Strings(hostIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range hostIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Chassis/%s", member)})
	}

	return redfishapi.Response(200, redfishapi.ChassisCollectionChassisCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Chassis",
		OdataType: "#ChassisCollection.ChassisCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Chassis Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdConnectionsConnectionIdDelete -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdConnectionsConnectionIdDelete(ctx context.Context, fabricId string, connectionId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	connectionSplit := strings.Split(connectionId, "connection")
	bladeId := connectionSplit[0]
	memoryChunkId := "memorychunk" + connectionSplit[1]

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.GetMemoryById(ctx, memoryChunkId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memory.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	if details.MemoryAppliancePort == "" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: Connection Type (%s) does not exist", connectionId)), nil
	}

	r := manager.RequestAssignMemory{
		MemoryId:  memoryChunkId,
		PortId:    details.MemoryAppliancePort,
		Operation: "unassign",
	}

	_, err = blade.AssignMemory(ctx, &r)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	return redfishapi.Response(200, redfishapi.ConnectionV131Connection{
		// OdataContext: "",
		// OdataEtag:        "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Connections/" + connectionId,
		OdataType: "#Connection.V1_3_1.Connection",
		// Actions:        redfishapi.ConnectionV131Actions{},
		// ConnectionKeys: redfishapi.ConnectionV131ConnectionKey{},
		ConnectionType: "CXL",
		// Description:      "",
		Id: connectionId,
		Links: redfishapi.ConnectionV131Links{TargetEndpoints: []redfishapi.OdataV4IdRef{
			{OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, bladeId+strings.Replace(details.MemoryAppliancePort, "port", "up", 1))},
		}},
		MemoryChunkInfo: []redfishapi.ConnectionV131MemoryChunkInfo{{MemoryChunk: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks/%s", fabricId, bladeId, memoryChunkId),
		}}},
		// MemoryRegionInfo: []redfishapi.ConnectionV131MemoryRegionInfo{},
		Name: connectionId,
		// Oem:              map[string]interface{}{},
		// Status:     redfishapi.ResourceStatus{},
		// VolumeInfo: []redfishapi.ConnectionV131VolumeInfo{},
	}), nil
}

// RedfishV1FabricsFabricIdConnectionsConnectionIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdConnectionsConnectionIdGet(ctx context.Context, fabricId string, connectionId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	connectionSplit := strings.Split(connectionId, "connection")
	bladeId := connectionSplit[0]
	memoryChunkId := "memorychunk" + connectionSplit[1]

	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.GetMemoryById(ctx, memoryChunkId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memory.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	if details.MemoryAppliancePort == "" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: Connection Type (%s) does not exist", connectionId)), nil
	}

	return redfishapi.Response(200, redfishapi.ConnectionV131Connection{
		// OdataContext: "",
		// OdataEtag:        "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Connections/" + connectionId,
		OdataType: "#Connection.V1_3_1.Connection",
		// Actions:        redfishapi.ConnectionV131Actions{},
		// ConnectionKeys: redfishapi.ConnectionV131ConnectionKey{},
		ConnectionType: "",
		// Description:      "",
		Id: fabricId,
		Links: redfishapi.ConnectionV131Links{TargetEndpoints: []redfishapi.OdataV4IdRef{
			{OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, bladeId+strings.Replace(details.MemoryAppliancePort, "port", "up", 1))},
		}},
		MemoryChunkInfo: []redfishapi.ConnectionV131MemoryChunkInfo{{MemoryChunk: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks/%s", fabricId, bladeId, memoryChunkId),
		}}},
		// MemoryRegionInfo: []redfishapi.ConnectionV131MemoryRegionInfo{},
		Name: fabricId,
		// Oem:              map[string]interface{}{},
		// Status:     redfishapi.ResourceStatus{},
		// VolumeInfo: []redfishapi.ConnectionV131VolumeInfo{},
	}), nil
}

// RedfishV1FabricsFabricIdConnectionsGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdConnectionsGet(ctx context.Context, fabricId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	members := []redfishapi.OdataV4IdRef{}
	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)
	for _, bladeId := range bladeIds {
		blade, err := appliance.GetBladeById(ctx, bladeId)
		if err != nil {
			return formatRedfishErrorResp(ctx, err.(*common.RequestError))
		}
		memoryIds := blade.GetAllMemoryIds()
		sort.Strings(memoryIds)

		for _, memId := range memoryIds {
			mem, err := blade.GetMemoryById(ctx, memId)
			if err != nil {
				return formatRedfishErrorResp(ctx, err.(*common.RequestError))
			}
			details, err := mem.GetDetails(ctx)
			if err != nil {
				return formatRedfishErrorResp(ctx, err.(*common.RequestError))
			}
			if details.MemoryAppliancePort != "" {
				connectionId := bladeId + strings.Replace(mem.Id, "memorychunk", "connection", 1)
				members = append(members, redfishapi.OdataV4IdRef{
					OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Connections/%s", fabricId, connectionId)})
			}
		}
	}

	return redfishapi.Response(200, redfishapi.ConnectionCollectionConnectionCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Connections",
		OdataType: "#ConnectionCollection.ConnectionCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Connection Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdConnectionsPost -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdConnectionsPost(ctx context.Context, fabricId string, connectionV131Connection redfishapi.ConnectionV131Connection) (redfishapi.ImplResponse, error) {

	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	if connectionV131Connection.ConnectionType != "CXL" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: Connection Type (%s) does not support", connectionV131Connection.ConnectionType)), nil
	}

	targetBladeId := ""
	r := manager.RequestAssignMemory{
		MemoryId:  "",
		PortId:    "",
		Operation: "assign",
	}

	// check format
	if len(connectionV131Connection.MemoryChunkInfo) == 0 {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: MemoryChunkInfo needs to be supplied")), nil
	}
	memoryChunkOdataId := connectionV131Connection.MemoryChunkInfo[0].MemoryChunk.OdataId
	if len(connectionV131Connection.Links.TargetEndpoints) == 0 {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: TargetEndpoints needs to be supplied")), nil
	}
	endpointOdataId := connectionV131Connection.Links.TargetEndpoints[0].OdataId

	for bladeId, blade := range appliance.GetBlades(ctx) {
		for _, memoryId := range blade.GetAllMemoryIds() {
			if fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks/%s", fabricId, bladeId, memoryId) == memoryChunkOdataId {
				targetBladeId = bladeId
				r.MemoryId = memoryId
				break
			}
		}
		if r.MemoryId == "" {
			continue
		}
		for _, portid := range blade.GetAllPortIds() {
			if fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, bladeId+strings.Replace(portid, "port", "up", 1)) == endpointOdataId {
				r.PortId = portid
				break
			}
		}
		if r.PortId != "" {
			targetBladeId = bladeId
			break
		}
	}

	if r.MemoryId == "" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: memory chunk (%s) not found", memoryChunkOdataId)), nil

	}

	if r.PortId == "" {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("error: Endpoint (%s) not found", endpointOdataId)), nil
	}

	blade, err := appliance.GetBladeById(ctx, targetBladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.AssignMemory(ctx, &r)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	connectionId := targetBladeId + strings.Replace(memory.Id, "memorychunk", "connection", 1)

	return redfishapi.Response(201, redfishapi.ConnectionV131Connection{
		// OdataContext: "",
		// OdataEtag:        "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Connections/" + connectionId,
		OdataType: "#Connection.V1_3_1.Connection",
		// Actions:        redfishapi.ConnectionV131Actions{},
		// ConnectionKeys: redfishapi.ConnectionV131ConnectionKey{},
		ConnectionType: "",
		// Description:      "",
		Id:              connectionId,
		Links:           redfishapi.ConnectionV131Links{},
		MemoryChunkInfo: []redfishapi.ConnectionV131MemoryChunkInfo{},
		// MemoryRegionInfo: []redfishapi.ConnectionV131MemoryRegionInfo{},
		Name: connectionId,
		// Oem:              map[string]interface{}{},
		// Status:     redfishapi.ResourceStatus{},
		// VolumeInfo: []redfishapi.ConnectionV131VolumeInfo{},
	}), nil
}

// RedfishV1FabricsFabricIdEndpointsEndpointIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdEndpointsEndpointIdGet(ctx context.Context, fabricId string, endpointId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	endpointIdSplit := strings.Split(endpointId, "up")
	bladeId := endpointIdSplit[0]
	portId := "port" + endpointIdSplit[1]
	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = blade.GetPortById(ctx, portId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// details, err := port.GetDetails(ctx)
	// if err != nil {
	// 	return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	// }

	links := redfishapi.EndpointV181Links{
		ConnectedPorts: []redfishapi.OdataV4IdRef{
			{OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches/%s/Ports/%s", fabricId, bladeId, portId)},
		},
		ConnectedPortsodataCount: 1,
		// Connections:                          []redfishapi.OdataV4IdRef{},
		// ConnectionsodataCount:                0,
	}
	return redfishapi.Response(200, redfishapi.EndpointV181Endpoint{
		// OdataContext:               "",
		// OdataEtag:                  "",
		OdataId:   fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, endpointId),
		OdataType: "#Endpoint.v1_8_1.Endpoint",
		// Actions:                    redfishapi.EndpointV181Actions{},
		// ConnectedEntities: []redfishapi.EndpointV181ConnectedEntity{},
		// Description:                "",
		// EndpointProtocol:           "",
		// HostReservationMemoryBytes: new(int64),
		// IPTransportDetails:         []redfishapi.EndpointV181IpTransportDetails{},
		Id:          endpointId,
		Identifiers: []redfishapi.ResourceIdentifier{},
		Links:       links,
		Name:        endpointId,
		// Oem:                        map[string]interface{}{},
		// PciId:                      redfishapi.EndpointV181PciId{},
		// Redundancy:                 []redfishapi.RedundancyRedundancy{},
		// RedundancyodataCount:       0,
		// Status:                     redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1FabricsFabricIdEndpointsGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdEndpointsGet(ctx context.Context, fabricId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)

	members := []redfishapi.OdataV4IdRef{}
	for _, bladeId := range bladeIds {
		blade, _ := appliance.GetBladeById(ctx, bladeId)
		for _, portid := range blade.GetAllPortIds() {
			members = append(members, redfishapi.OdataV4IdRef{
				OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints/%s", fabricId, bladeId+strings.Replace(portid, "port", "up", 1))})
		}
	}

	return redfishapi.Response(200, redfishapi.EndpointCollectionEndpointCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints", fabricId),
		OdataType: "#EndpointsCollection.EndpointsCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdGet(ctx context.Context, fabricId string) (redfishapi.ImplResponse, error) {
	_, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.FabricV131Fabric{
		// OdataContext:   "",
		// OdataEtag:      "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId,
		OdataType: "#Fabric.v1_3_1.Fabric",
		// Actions:        redfishapi.FabricV131Actions{},
		// AddressPools:   redfishapi.OdataV4IdRef{},
		Connections: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Connections", fabricId),
		},
		// Description:    "",
		// EndpointGroups: redfishapi.OdataV4IdRef{},
		Endpoints: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Endpoints", fabricId),
		},
		FabricType: "Memory Appliance",
		Id:         fabricId,
		// Links:          redfishapi.FabricV131Links{},
		// MaxZones:       new(int64),
		Name: fabricId,
		// Oem:            map[string]interface{}{},
		// Status:         redfishapi.ResourceStatus{},
		Switches: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches", fabricId),
		},
		// UUID:           "",
		// Zones:          redfishapi.OdataV4IdRef{},
	}), nil
}

// RedfishV1FabricsFabricIdSwitchesGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdSwitchesGet(ctx context.Context, fabricId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by blade id
	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)

	members := []redfishapi.OdataV4IdRef{}
	for _, member := range bladeIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches/%s", fabricId, member)})
	}

	return redfishapi.Response(200, redfishapi.SwitchCollectionSwitchCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Switches",
		OdataType: "#SwitchCollection.SwitchCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Switch Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdSwitchesSwitchIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdSwitchesSwitchIdGet(ctx context.Context, fabricId string, switchId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = appliance.GetBladeById(ctx, switchId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.SwitchV192Switch{
		// OdataContext:            "",
		// OdataEtag:               "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Switches/" + switchId,
		OdataType: "#Switch.v1_9_2.Switch",
		// Actions:                 redfishapi.SwitchV192Actions{},
		// AssetTag:                new(string),
		// CXL:                     redfishapi.SwitchV192Cxl{},
		// Certificates:            redfishapi.OdataV4IdRef{},
		// CurrentBandwidthGbps:    new(float32),
		// Description:             "",
		// DomainID:                new(int64),
		// Enabled:                 false,
		// EnvironmentMetrics:      redfishapi.OdataV4IdRef{},
		// FirmwareVersion:         new(string),
		Id: switchId,
		// IndicatorLED:            "",
		// IsManaged:               new(bool),
		// Links:                   redfishapi.SwitchV192Links{},
		// Location:                redfishapi.ResourceLocation{},
		// LocationIndicatorActive: new(bool),
		// LogServices:             redfishapi.OdataV4IdRef{},
		// Manufacturer:            new(string),
		// MaxBandwidthGbps:        new(float32),
		// Measurements:            []redfishapi.SoftwareInventoryMeasurementBlock{},
		// Metrics:                 redfishapi.OdataV4IdRef{},
		// Model:                   new(string),
		Name: switchId,
		// Oem:                     map[string]interface{}{},
		// PartNumber:              new(string),
		Ports: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches/%s/Ports", fabricId, switchId),
		},
		// PowerState:              "",
		// Redundancy:              []redfishapi.RedundancyRedundancy{},
		// RedundancyodataCount:    0,
		// SKU:                     new(string),
		// SerialNumber:            new(string),
		// Status:                  redfishapi.ResourceStatus{},
		// SupportedProtocols:      []redfishapi.ProtocolProtocol{},
		// SwitchType:              "",
		// TotalSwitchWidth:        new(int64),
		// UUID:                    "",
	}), nil
}

// RedfishV1FabricsFabricIdSwitchesSwitchIdPortsGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdSwitchesSwitchIdPortsGet(ctx context.Context, fabricId string, switchId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, switchId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by port id
	portIds := blade.GetAllPortIds()
	sort.Strings(portIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range portIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s/Switches/%s/Ports/%s", fabricId, switchId, member)})
	}

	return redfishapi.Response(200, redfishapi.PortCollectionPortCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Switches/" + switchId + "/Ports",
		OdataType: "#PortCollection.PortCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Port Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1FabricsFabricIdSwitchesSwitchIdPortsPortIdGet -
func (cfm *CfmApiService) RedfishV1FabricsFabricIdSwitchesSwitchIdPortsPortIdGet(ctx context.Context, fabricId string, switchId string, portId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, fabricId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, switchId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	port, err := blade.GetPortById(ctx, portId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = port.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.PortV1110Port{
		// OdataContext:            "",
		// OdataEtag:               "",
		OdataId:   "/redfish/v1/Fabrics/" + fabricId + "/Switches/" + switchId + "/Ports/" + portId,
		OdataType: "#Port.v1_11_1.Port",
		// Actions:                 redfishapi.PortV1110Actions{},
		// ActiveWidth:      details.Width,
		// CXL:                     redfishapi.PortV1110Cxl{},
		// CapableProtocolVersions: []*string{},
		// CurrentProtocolVersion:  new(string),
		// CurrentSpeedGbps:        new(float32),
		// Description:             "",
		// Enabled:                 false,
		// EnvironmentMetrics:      redfishapi.OdataV4IdRef{},
		// Ethernet:                redfishapi.PortV1110EthernetProperties{},
		// FibreChannel:            redfishapi.PortV1110FibreChannelProperties{},
		// FunctionMaxBandwidth:    []redfishapi.PortV1110FunctionMaxBandwidth{},
		// FunctionMinBandwidth:    []redfishapi.PortV1110FunctionMinBandwidth{},
		// GenZ:                    redfishapi.PortV1110GenZ{},
		Id: portId,
		// InfiniBand:              redfishapi.PortV1110InfiniBandProperties{},
		// InterfaceEnabled:        new(bool),
		// LinkConfiguration:       []redfishapi.PortV1110LinkConfiguration{},
		// LinkNetworkTechnology:   "",
		// LinkState:               "",
		// LinkStatus:              "",
		// LinkTransitionIndicator: 0,
		// Links:                   redfishapi.PortV1110Links{},
		// Location:                redfishapi.ResourceLocation{},
		// LocationIndicatorActive: new(bool),
		// MaxFrameSize:            new(int64),
		// MaxSpeedGbps:            new(float32),
		// Metrics:                 redfishapi.OdataV4IdRef{},
		Name: portId,
		// Oem:                     map[string]interface{}{},
		// PortId:                  new(string),
		// PortMedium:              "",
		// PortProtocol:            "",
		// PortType:                "",
		// RemotePortId:            new(string),
		// SFP:                     redfishapi.PortV1110Sfp{},
		// SignalDetected:          new(bool),
		// Status:                  redfishapi.ResourceStatus{},
		// Width:                   new(int64),
	}), nil
}

// RedfishV1FabricsGet -
func (cfm *CfmApiService) RedfishV1FabricsGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	// order returned uris by appliance id
	applianceIds := manager.GetAllApplianceIds()
	sort.Strings(applianceIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range applianceIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Fabrics/%s", member)})
	}

	return redfishapi.Response(200, redfishapi.FabricCollectionFabricCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Fabrics",
		OdataType: "#FabricCollection.FabricCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Fabric Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1Get -
func (cfm *CfmApiService) RedfishV1Get(ctx context.Context) (redfishapi.ImplResponse, error) {
	vendor := "Seagate"
	product := "Memory Appliance Composer & Fabric Manager Redfish Service"

	oem := map[string]interface{}{}
	oem["ServiceVersion"] = cfm.Version

	root := redfishapi.ServiceRootV1161ServiceRoot{
		// OdataContext: "/redfish/v1/$metadata#ServiceRoot.ServiceRoot",
		OdataId:   "/redfish/v1",
		OdataType: "#ServiceRoot.v1_16_1.ServiceRoot",
		Chassis:   redfishapi.OdataV4IdRef{OdataId: "/redfish/v1/Chassis"},
		// Description:    "CXL Host ServiceRoot",
		Fabrics: redfishapi.OdataV4IdRef{OdataId: "/redfish/v1/Fabrics"},
		Id:      "CXL Host ServiceRoot",
		Name:    "CXL Host",
		// Oem:            oem,
		Product:        &product,
		RedfishVersion: "1.20.0",
		Systems:        redfishapi.OdataV4IdRef{OdataId: "/redfish/v1/Systems"},
		Vendor:         &vendor,
	}

	return redfishapi.Response(http.StatusOK, root), nil
}

// RedfishV1MetadataGet -
func (cfm *CfmApiService) RedfishV1MetadataGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	metadata := `<?xml version="1.0" encoding="UTF-8"?>
	<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
		<edmx:DataServices>
			<Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="Service">
				<EntityContainer Name="Service" Extends="ServiceRoot.v1_2_0.ServiceContainer" />
			</Schema>
		</edmx:DataServices>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Chassis_v1.xml">
			<edmx:Include Namespace="Chassis" />
				<edmx:Include Namespace="Chassis.v1_21_0" />
		</edmx:Reference>
			<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/ChassisCollection_v1.xml">
				<edmx:Include Namespace="ChassisCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Fabric_v1.xml">
			<edmx:Include Namespace="Fabric" />
				<edmx:Include Namespace="Fabric.v1_3_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/FabricCollection_v1.xml">
			<edmx:Include Namespace="FabricCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Memory_v1.xml">
			<edmx:Include Namespace="Memory" />
				<edmx:Include Namespace="Memory.v1_16_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryCollection_v1.xml">
			<edmx:Include Namespace="MemoryCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Port_v1.xml">
			<edmx:Include Namespace="Port" />
				<edmx:Include Namespace="Port.v1_7_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/PortCollection_v1.xml">
			<edmx:Include Namespace="PortCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Switch_v1.xml">
			<edmx:Include Namespace="Switch" />
				<edmx:Include Namespace="Switch.v1_8_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/SwitchCollection_v1.xml">
			<edmx:Include Namespace="SwitchCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryDomain_v1.xml">
			<edmx:Include Namespace="MemoryDomain" />
				<edmx:Include Namespace="MemoryDomain.v1_5_0" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryDomainCollection_v1.xml">
			<edmx:Include Namespace="MemoryDomainCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryChunks_v1.xml">
			<edmx:Include Namespace="MemoryChunks" />
				<edmx:Include Namespace="MemoryChunks.v1_6_1" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/MemoryChunksCollection_v1.xml">
			<edmx:Include Namespace="MemoryChunksCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/PCIeDevice_v1.xml">
			<edmx:Include Namespace="PCIeDevice" />
				<edmx:Include Namespace="PCIeDevice.v1_13_0" />
		</edmx:Reference>
			<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/PCIeDeviceCollection_v1.xml">
		<edmx:Include Namespace="PCIeDeviceCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/CXLLogicalDevice_v1.xml">
			<edmx:Include Namespace="CXLLogicalDevice" />
				<edmx:Include Namespace="CXLLogicalDevice.v1_1_1" />
		</edmx:Reference>
			<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/CXLLogicalDeviceCollection_v1.xml">
		<edmx:Include Namespace="CXLLogicalDeviceCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Endpoint_v1.xml">
			<edmx:Include Namespace="Endpoint" />
				<edmx:Include Namespace="Endpoint.v1_8_1" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/EndpointCollection_v1.xml">
			<edmx:Include Namespace="EndpointCollection" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/Connection_v1.xml">
			<edmx:Include Namespace="Connection" />
				<edmx:Include Namespace="Connection.v1_3_1" />
		</edmx:Reference>
		<edmx:Reference Uri="http://redfishapi.dmtf.org/schemas/v1/ConnectionCollection_v1.xml">
			<edmx:Include Namespace="ConnectionCollection" />
		</edmx:Reference>
	</edmx:Edmx>`

	return redfishapi.Response(http.StatusOK, metadata), nil
}

// RedfishV1OdataGet -
func (cfm *CfmApiService) RedfishV1OdataGet(ctx context.Context) (redfishapi.ImplResponse, error) {

	resource := redfishapi.RedfishV1OdataGet200Response{
		// OdataContext: "/redfish/v1/odata",
	}

	resource.Value = append(resource.Value, redfishapi.RedfishV1OdataGet200ResponseValueInner{
		Kind: "Singleton",
		Name: "Service",
		Url:  "/redfish/v1",
	})

	resource.Value = append(resource.Value, redfishapi.RedfishV1OdataGet200ResponseValueInner{
		Kind: "Singleton",
		Name: "Chassis",
		Url:  "/redfish/v1/Chassis",
	})

	resource.Value = append(resource.Value, redfishapi.RedfishV1OdataGet200ResponseValueInner{
		Kind: "Singleton",
		Name: "Fabrics",
		Url:  "/redfish/v1/Fabrics",
	})

	resource.Value = append(resource.Value, redfishapi.RedfishV1OdataGet200ResponseValueInner{
		Kind: "Singleton",
		Name: "Systems",
		Url:  "/redfish/v1/Systems",
	})

	return redfishapi.Response(http.StatusOK, resource), nil
}

// RedfishV1SystemsComputerSystemIdGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdGet(ctx context.Context, computerSystemId string) (redfishapi.ImplResponse, error) {
	_, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	return redfishapi.Response(200, redfishapi.ComputerSystemV1220ComputerSystem{
		// OdataContext:            "",
		// OdataEtag:               "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId,
		OdataType: "#ComputerSystem.v1_22_0.ComputerSystem",
		// Actions:                 redfishapi.ComputerSystemV1220Actions{},
		// AssetTag:                new(string),
		// Bios:                    redfishapi.OdataV4IdRef{},
		// BiosVersion:             new(string),
		// Boot:                    redfishapi.ComputerSystemV1220Boot{},
		// BootProgress:            redfishapi.ComputerSystemV1220BootProgress{},
		// Certificates:            redfishapi.OdataV4IdRef{},
		// Composition:             redfishapi.ComputerSystemV1220Composition{},
		// Description:             "",
		// EthernetInterfaces:      redfishapi.OdataV4IdRef{},
		// FabricAdapters:          redfishapi.OdataV4IdRef{},
		// GraphicalConsole:        redfishapi.ComputerSystemV1220HostGraphicalConsole{},
		// GraphicsControllers:     redfishapi.OdataV4IdRef{},
		// HostName:                new(string),
		// HostWatchdogTimer:       redfishapi.ComputerSystemV1220WatchdogTimer{},
		// HostedServices:          redfishapi.ComputerSystemV1220HostedServices{},
		// HostingRoles:            []redfishapi.ComputerSystemV1220HostingRole{},
		Id: computerSystemId,
		// IdlePowerSaver: redfishapi.ComputerSystemV1220IdlePowerSaver{},
		// IndicatorLED:            "",
		// KeyManagement:           redfishapi.ComputerSystemV1220KeyManagement{},
		// LastResetTime:           time.Time{},
		// Links:                   redfishapi.ComputerSystemV1220Links{},
		// LocationIndicatorActive: new(bool),
		// LogServices:             redfishapi.OdataV4IdRef{},
		// Manufacturer:            new(string),
		// ManufacturingMode:       new(bool),
		// Measurements:            []redfishapi.SoftwareInventoryMeasurementBlock{},
		Memory: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/Memory", computerSystemId),
		},
		MemoryDomains: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains", computerSystemId),
		},
		// MemorySummary:           redfishapi.ComputerSystemV1220MemorySummary{},
		// Model:                   new(string),
		Name: computerSystemId,
		// NetworkInterfaces:       redfishapi.OdataV4IdRef{},
		// Oem:                     map[string]interface{}{},
		// OperatingSystem:         redfishapi.OdataV4IdRef{},
		// PCIeDevices:             []redfishapi.OdataV4IdRef{},
		// PCIeDevicesodataCount:   0,
		// PCIeFunctions:           []redfishapi.OdataV4IdRef{},
		// PCIeFunctionsodataCount: 0,
		// PartNumber:              new(string),
		// PowerCycleDelaySeconds:  new(float32),
		// PowerMode:               "",
		// PowerOffDelaySeconds:    new(float32),
		// PowerOnDelaySeconds:     new(float32),
		// PowerRestorePolicy:      "",
		// PowerState:              "",
		// ProcessorSummary:        redfishapi.ComputerSystemV1220ProcessorSummary{},
		// Processors:              redfishapi.OdataV4IdRef{},
		// Redundancy:              []redfishapi.RedundancyRedundancy{},
		// RedundancyodataCount:    0,
		// SKU:                     new(string),
		// SecureBoot:              redfishapi.OdataV4IdRef{},
		// SerialConsole:           redfishapi.ComputerSystemV1220HostSerialConsole{},
		// SerialNumber:            new(string),
		// SimpleStorage:           redfishapi.OdataV4IdRef{},
		// Status:                  redfishapi.ResourceStatus{},
		// Storage:                 redfishapi.OdataV4IdRef{},
		// SubModel:                new(string),
		// SystemType:              "",
		// TrustedModules:          []redfishapi.ComputerSystemV1220TrustedModules{},
		// USBControllers:          redfishapi.OdataV4IdRef{},
		// UUID:                    "",
		// VirtualMedia:            redfishapi.OdataV4IdRef{},
		// VirtualMediaConfig:      redfishapi.ComputerSystemV1220VirtualMediaConfig{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsGet(ctx context.Context, computerSystemId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by blade id
	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range bladeIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s", computerSystemId, member)})
	}

	return redfishapi.Response(200, redfishapi.MemoryDomainCollectionMemoryDomainCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains",
		OdataType: "#MemoryDomainCollection.MemoryDomainCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "MemoryDomain Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdGet(ctx context.Context, computerSystemId string, memoryDomainId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	_, err = appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	allowsMemoryChunkCreation := true
	return redfishapi.Response(200, redfishapi.MemoryDomainV150MemoryDomain{
		// OdataContext:              "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId,
		OdataType: "#MemoryDomain.v1_5_0.MemoryDomain",
		// Actions:                   redfishapi.MemoryDomainV150Actions{},
		// AllowsBlockProvisioning:   new(bool),
		AllowsMemoryChunkCreation: &allowsMemoryChunkCreation,
		// AllowsMirroring:           new(bool),
		// AllowsSparing:             new(bool),
		// Description:               "",
		Id: memoryDomainId,
		// InterleavableMemorySets:   []redfishapi.MemoryDomainV150MemorySet{},
		// Links: redfishapi.MemoryDomainV150Links{},
		// MemoryChunkIncrementMiB:   new(int64),
		MemoryChunks: redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks", computerSystemId, memoryDomainId),
		},
		// MemorySizeMiB:             new(int64),
		// MinMemoryChunkSizeMiB:     new(int64),
		Name: memoryDomainId,
		// Oem:                       map[string]interface{}{},
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksGet(ctx context.Context, computerSystemId string, memoryDomainId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by memory id
	memoryIds := blade.GetAllMemoryIds()
	sort.Strings(memoryIds)
	members := []redfishapi.OdataV4IdRef{}
	for _, member := range memoryIds {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/MemoryDomains/%s/MemoryChunks/%s", computerSystemId, memoryDomainId, member)})
	}

	return redfishapi.Response(200, redfishapi.MemoryChunksCollectionMemoryChunksCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId + "/MemoryChunks",
		OdataType: "#MemoryChunksCollection.MemoryChunksCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "MemoryChunk Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdDelete -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdDelete(ctx context.Context, computerSystemId string, memoryDomainId string, memoryChunksId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.FreeMemoryById(ctx, memoryChunksId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	memorySize := int64(memory.SizeMiB)

	return redfishapi.Response(200, redfishapi.MemoryChunksV161MemoryChunks{
		// OdataContext:              "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId + "/MemoryChunks/" + memoryChunksId,
		OdataType: "#MemoryChunks.V1_6_1.MemoryChunks",
		// Actions:                   redfishapi.MemoryChunksV161Actions{},
		// AddressRangeOffsetMiB:     new(int64),
		// AddressRangeType:          "",
		// Description:               "",
		// DisplayName:               new(string),
		Id: memoryChunksId,
		// InterleaveSets:            []redfishapi.MemoryChunksV161InterleaveSet{},
		// IsMirrorEnabled:           new(bool),
		// IsSpare:                   new(bool),
		// Links:                     redfishapi.MemoryChunksV161Links{},
		// MediaLocation:             "",
		MemoryChunkSizeMiB: &memorySize,
		Name:               memoryChunksId,
		// Oem:                       map[string]interface{}{},
		// RequestedOperationalState: "",
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksMemoryChunksIdGet(ctx context.Context, computerSystemId string, memoryDomainId string, memoryChunksId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memory, err := blade.GetMemoryById(ctx, memoryChunksId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	details, err := memory.GetDetails(ctx)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	memorySize := int64(details.SizeMiB)

	return redfishapi.Response(200, redfishapi.MemoryChunksV161MemoryChunks{
		// OdataContext:              "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId + "/MemoryChunks/" + memoryChunksId,
		OdataType: "#MemoryChunks.V1_6_1.MemoryChunks",
		// Actions:                   redfishapi.MemoryChunksV161Actions{},
		// AddressRangeOffsetMiB:     new(int64),
		// AddressRangeType:          "",
		// Description:               "",
		// DisplayName:               new(string),
		Id: memoryChunksId,
		// InterleaveSets:            []redfishapi.MemoryChunksV161InterleaveSet{},
		// IsMirrorEnabled:           new(bool),
		// IsSpare:                   new(bool),
		// Links:                     redfishapi.MemoryChunksV161Links{},
		// MediaLocation:             "",
		MemoryChunkSizeMiB: &memorySize,
		Name:               memoryChunksId,
		// Oem:                       map[string]interface{}{},
		// RequestedOperationalState: "",
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksPost -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryDomainsMemoryDomainIdMemoryChunksPost(ctx context.Context, computerSystemId string, memoryDomainId string, memoryChunksV161MemoryChunks redfishapi.MemoryChunksV161MemoryChunks) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	blade, err := appliance.GetBladeById(ctx, memoryDomainId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// TODO: move this logic into manager.go
	resourceIds := []string{}
	blocksNeededPerChannel := int32(*memoryChunksV161MemoryChunks.MemoryChunkSizeMiB) / blade.ResourceSizeMib / int32(len(memoryChunksV161MemoryChunks.InterleaveSets))

	for _, dpInfo := range memoryChunksV161MemoryChunks.InterleaveSets {
		if dpInfo.Memory.OdataId == "" {
			return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("link to memory is required")), nil
		}
		if dpInfo.OffsetMiB == nil {
			return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("OffsetMiB field is required")), nil
		}

		memoryIdSplit := strings.Split(dpInfo.Memory.OdataId, "dp")
		portId, _ := strconv.Atoi(memoryIdSplit[1])

		if fmt.Sprintf("/redfish/v1/Systems/%s/Memory/%sdp%d", computerSystemId, memoryDomainId, portId) != dpInfo.Memory.OdataId {
			return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("memory (%s) is invalid", dpInfo.Memory.OdataId)), nil
		}
		if int32(*dpInfo.OffsetMiB)%blade.ResourceSizeMib != 0 {
			return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("OffsetMiB (%d) is aligned to resource block size", dpInfo.OffsetMiB)), nil
		}
		for resourceId, resource := range blade.Resources {
			if portId == int(resource.GetChannelId()) {
				if int32(*dpInfo.OffsetMiB)/blade.ResourceSizeMib <= resource.GetChannelResourceIndex() &&
					int32(*dpInfo.OffsetMiB)/blade.ResourceSizeMib+blocksNeededPerChannel > resource.GetChannelResourceIndex() {
					if resource.GetCompositionState() == backend.RESOURCE_STATE_UNUSED {
						resourceIds = append(resourceIds, resourceId)
					} else {
						return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("resource (%s) is not available", resourceId)), nil
					}
				}

			}
		}

	}

	if int32(len(resourceIds)) != int32(*memoryChunksV161MemoryChunks.MemoryChunkSizeMiB)/blade.ResourceSizeMib {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("cannot find request memory resoureces")), nil
	}

	memory, err := blade.ComposeMemoryByResource(ctx, "", resourceIds)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	memorySize := int64(memory.SizeMiB)
	memoryChunksId := memory.Id

	return redfishapi.Response(201, redfishapi.MemoryChunksV161MemoryChunks{
		// OdataContext:              "",
		// OdataEtag:                 "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/MemoryDomains/" + memoryDomainId + "/MemoryChunks/" + memoryChunksId,
		OdataType: "#MemoryChunks.V1_6_1.MemoryChunks",
		// Actions:                   redfishapi.MemoryChunksV161Actions{},
		// AddressRangeOffsetMiB:     new(int64),
		// AddressRangeType:          "",
		// Description:               "",
		// DisplayName:               new(string),
		Id: memoryChunksId,
		// InterleaveSets:            []redfishapi.MemoryChunksV161InterleaveSet{},
		// IsMirrorEnabled:           new(bool),
		// IsSpare:                   new(bool),
		// Links:                     redfishapi.MemoryChunksV161Links{},
		// MediaLocation:             "",
		MemoryChunkSizeMiB: &memorySize,
		Name:               memoryChunksId,
		// Oem:                       map[string]interface{}{},
		// RequestedOperationalState: "",
		// Status:                    redfishapi.ResourceStatus{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryGet(ctx context.Context, computerSystemId string) (redfishapi.ImplResponse, error) {
	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	// order returned uris by blade id
	bladeIds := appliance.GetAllBladeIds()
	sort.Strings(bladeIds)

	members := []redfishapi.OdataV4IdRef{}
	for _, bladeId := range bladeIds {
		blade, _ := appliance.GetBladeById(ctx, bladeId)

		for portId := 0; portId < int(blade.NumResourceChannels); portId++ {
			members = append(members, redfishapi.OdataV4IdRef{
				OdataId: fmt.Sprintf("/redfish/v1/Systems/%s/Memory/%s", computerSystemId, fmt.Sprintf("%sdp%d", bladeId, portId))})
		}
	}

	return redfishapi.Response(200, redfishapi.MemoryCollectionMemoryCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/Memory",
		OdataType: "#MemoryCollection.MemoryCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "Memory Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

// RedfishV1SystemsComputerSystemIdMemoryMemoryIdGet -
func (cfm *CfmApiService) RedfishV1SystemsComputerSystemIdMemoryMemoryIdGet(ctx context.Context, computerSystemId string, memoryId string) (redfishapi.ImplResponse, error) {

	appliance, err := manager.GetApplianceById(ctx, computerSystemId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}

	memoryIdSplit := strings.Split(memoryId, "dp")
	bladeId := memoryIdSplit[0]
	portId, _ := strconv.Atoi(memoryIdSplit[1])
	blade, err := appliance.GetBladeById(ctx, bladeId)
	if err != nil {
		return formatRedfishErrorResp(ctx, err.(*common.RequestError))
	}
	if int32(portId) >= blade.NumResourceChannels {
		return redfishapi.Response(http.StatusBadRequest, fmt.Errorf("port Id (%d) is not found", portId)), nil
	}

	capacityMiB := int64(blade.ResourceSizeMib/blade.NumResourceChannels) * int64(len(blade.Resources))

	return redfishapi.Response(200, redfishapi.MemoryV1190Memory{
		// OdataContext:                            "",
		// OdataEtag:                               "",
		OdataId:   "/redfish/v1/Systems/" + computerSystemId + "/Memory/" + memoryId,
		OdataType: "#Memory.v1_19_0.Memory",
		// Actions:                                 redfishapi.MemoryV1190Actions{},
		// AllocationAlignmentMiB:                  new(int64),
		// AllocationIncrementMiB:                  new(int64),
		// AllowedSpeedsMHz:                        []int64{},
		// Assembly:                                redfishapi.OdataV4IdRef{},
		// BaseModuleType:                          "",
		// BusWidthBits:                            new(int64),
		// CXL:                                     redfishapi.MemoryV1190Cxl{},
		// CacheSizeMiB:                            new(int64),
		CapacityMiB: &capacityMiB,
		// Certificates:                            redfishapi.OdataV4IdRef{},
		// ConfigurationLocked:                     new(bool),
		// DataWidthBits:                           new(int64),
		// Description:                             "",
		// DeviceID:                                new(string),
		// DeviceLocator:                           new(string),
		// Enabled:                                 false,
		// EnvironmentMetrics:                      redfishapi.OdataV4IdRef{},
		// ErrorCorrection:                         "",
		// FirmwareApiVersion:                      new(string),
		// FirmwareRevision:                        new(string),
		// FunctionClasses:                         []string{},
		// HealthData:                              redfishapi.MemoryV1190HealthData{},
		Id: memoryId,
		// IsRankSpareEnabled:                      new(bool),
		// IsSpareDeviceEnabled:                    new(bool),
		// Links:                                   redfishapi.MemoryV1190Links{},
		// Location:                                redfishapi.ResourceLocation{},
		// LocationIndicatorActive:                 new(bool),
		// Log:                                     redfishapi.OdataV4IdRef{},
		// LogicalSizeMiB:                          new(int64),
		// Manufacturer:                            new(string),
		// MaxTDPMilliWatts:                        []int64{},
		// Measurements:                            []redfishapi.SoftwareInventoryMeasurementBlock{},
		// MemoryDeviceType:                        "",
		// MemoryLocation:                          redfishapi.MemoryV1190MemoryLocation{},
		// MemoryMedia:                             []redfishapi.MemoryV1190MemoryMedia{},
		// MemorySubsystemControllerManufacturerID: new(string),
		// MemorySubsystemControllerProductID:      new(string),
		// MemoryType:                              "",
		// Metrics:                                 redfishapi.OdataV4IdRef{},
		// Model:                                   new(string),
		// ModuleManufacturerID:                    new(string),
		// ModuleProductID:                         new(string),
		Name: memoryId,
		// NonVolatileSizeLimitMiB:                 0,
		// NonVolatileSizeMiB:                      new(int64),
		// Oem:                                     map[string]interface{}{},
		// OperatingMemoryModes:                    []redfishapi.MemoryV1190OperatingMemoryModes{},
		// OperatingSpeedMhz:                       new(int64),
		// OperatingSpeedRangeMHz:                  redfishapi.ControlControlRangeExcerpt{},
		// PartNumber:                              new(string),
		// PersistentRegionNumberLimit:             new(int64),
		// PersistentRegionSizeLimitMiB:            new(int64),
		// PersistentRegionSizeMaxMiB:              new(int64),
		// PoisonListMaxMediaErrorRecords:          0,
		// PowerManagementPolicy:                   redfishapi.MemoryV1190PowerManagementPolicy{},
		// RankCount:                               new(int64),
		// Regions:                                 []redfishapi.MemoryV1190RegionSet{},
		// SecurityCapabilities:                    redfishapi.MemoryV1190SecurityCapabilities{},
		// SecurityState:                           "",
		// SecurityStates:                          redfishapi.MemoryV1190SecurityStateInfo{},
		// SerialNumber:                            new(string),
		// SpareDeviceCount:                        new(int64),
		// SparePartNumber:                         new(string),
		// Status:                                  redfishapi.ResourceStatus{},
		// SubsystemDeviceID:                       new(string),
		// SubsystemVendorID:                       new(string),
		// VendorID:                                new(string),
		// VolatileRegionNumberLimit:               new(int64),
		// VolatileRegionSizeLimitMiB:              new(int64),
		// VolatileRegionSizeMaxMiB:                new(int64),
		// VolatileSizeLimitMiB:                    0,
		// VolatileSizeMiB:                         new(int64),
	}), nil
}

// RedfishV1SystemsGet -
func (cfm *CfmApiService) RedfishV1SystemsGet(ctx context.Context) (redfishapi.ImplResponse, error) {
	// order returned uris by appliance id
	applianceIds := manager.GetAllApplianceIds()
	sort.Strings(applianceIds)

	appliances := manager.GetAppliances(ctx)
	members := []redfishapi.OdataV4IdRef{}
	for member := range appliances {
		members = append(members, redfishapi.OdataV4IdRef{
			OdataId: fmt.Sprintf("/redfish/v1/Systems/%s", member)})
	}

	return redfishapi.Response(200, redfishapi.ComputerSystemCollectionComputerSystemCollection{
		// OdataContext:         "",
		// OdataEtag:            "",
		OdataId:   "/redfish/v1/Systems",
		OdataType: "#ComputerSystemCollection.ComputerSystemCollection",
		// Description:          "",
		Members:           members,
		MembersodataCount: int64(len(members)),
		// MembersodataNextLink: "",
		Name: "ComputerSystem Collection",
		// Oem:                  map[string]interface{}{},
	}), nil
}

func formatRedfishErrorResp(ctx context.Context, re *common.RequestError) (redfishapi.ImplResponse, error) {
	status := redfishapi.RedfishError{
		Error: redfishapi.RedfishErrorError{
			MessageExtendedInfo: []redfishapi.MessageV120Message{{
				Message: re.Err.Error(),
				Oem:     map[string]interface{}{"Uri": common.GetContextString(ctx, common.KeyUri)},
			}},
			Code:    strconv.Itoa(re.StatusCode.HttpStatusCode()),
			Message: re.StatusCode.String(),
		},
	}
	return redfishapi.Response(re.StatusCode.HttpStatusCode(), status), nil
}
