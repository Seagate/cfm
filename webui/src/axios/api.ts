/* tslint:disable */
/* eslint-disable */
/**
 * Composer and Fabric Manager Service OpenAPI
 * This API allows users to interact through the CFM Service with CXL Hosts and Memory Appliances. The main purpose of this interface is to allow the retrieval of information and the creation and mapping of memory from a Memory Appliance to a CXL host. 
 *
 * The version of the OpenAPI document: 1.6.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Appliance
 */
export interface Appliance {
    /**
     * The id uniquely identifies the resource within a resource collection. Since URIs are constructed with ids, must not contain RFC1738 unsafe characters.
     * @type {string}
     * @memberof Appliance
     */
    'id': string;
    /**
     * The IP Address in dot notation of the service
     * @type {string}
     * @memberof Appliance
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof Appliance
     */
    'port'?: number;
    /**
     * A response string
     * @type {string}
     * @memberof Appliance
     */
    'status'?: string;
    /**
     * 
     * @type {MemberItem}
     * @memberof Appliance
     */
    'blades'?: MemberItem;
    /**
     * A mebibyte equals 2**20 or 1,048,576 bytes.
     * @type {number}
     * @memberof Appliance
     */
    'totalMemoryAvailableMiB'?: number;
    /**
     * A mebibyte equals 2**20 or 1,048,576 bytes.
     * @type {number}
     * @memberof Appliance
     */
    'totalMemoryAllocatedMiB'?: number;
}
/**
 * 
 * @export
 * @interface AssignMemoryRequest
 */
export interface AssignMemoryRequest {
    /**
     * The CXL port name on the Memory Appliance
     * @type {string}
     * @memberof AssignMemoryRequest
     */
    'Port': string;
    /**
     * -assign- an existing memory to a port or -unassign- an existing link between memory and port
     * @type {string}
     * @memberof AssignMemoryRequest
     */
    'Operation': AssignMemoryRequestOperationEnum;
}

export const AssignMemoryRequestOperationEnum = {
    Assign: 'assign',
    Unassign: 'unassign'
} as const;

export type AssignMemoryRequestOperationEnum = typeof AssignMemoryRequestOperationEnum[keyof typeof AssignMemoryRequestOperationEnum];

/**
 * 
 * @export
 * @interface Blade
 */
export interface Blade {
    /**
     * The id uniquely identifies the resource within a resource collection. Since URIs are constructed with ids, must not contain RFC1738 unsafe characters.
     * @type {string}
     * @memberof Blade
     */
    'id': string;
    /**
     * The IP Address in dot notation of the service
     * @type {string}
     * @memberof Blade
     */
    'ipAddress': string;
    /**
     * 
     * @type {number}
     * @memberof Blade
     */
    'port': number;
    /**
     * A response string
     * @type {string}
     * @memberof Blade
     */
    'status'?: string;
    /**
     * 
     * @type {MemberItem}
     * @memberof Blade
     */
    'ports'?: MemberItem;
    /**
     * 
     * @type {MemberItem}
     * @memberof Blade
     */
    'resources'?: MemberItem;
    /**
     * 
     * @type {MemberItem}
     * @memberof Blade
     */
    'memory'?: MemberItem;
    /**
     * A mebibyte equals 2**20 or 1,048,576 bytes.
     * @type {number}
     * @memberof Blade
     */
    'totalMemoryAvailableMiB'?: number;
    /**
     * A mebibyte equals 2**20 or 1,048,576 bytes.
     * @type {number}
     * @memberof Blade
     */
    'totalMemoryAllocatedMiB'?: number;
}
/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * 
     * @type {number}
     * @memberof Collection
     */
    'memberCount': number;
    /**
     * 
     * @type {Array<MemberItem>}
     * @memberof Collection
     */
    'members': Array<MemberItem>;
}
/**
 * 
 * @export
 * @interface ComposeMemoryByResourceRequest
 */
export interface ComposeMemoryByResourceRequest {
    /**
     * The CXL port name on the Memory Appliance
     * @type {string}
     * @memberof ComposeMemoryByResourceRequest
     */
    'Port'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ComposeMemoryByResourceRequest
     */
    'memoryResources': Array<string>;
}
/**
 * 
 * @export
 * @interface ComposeMemoryRequest
 */
export interface ComposeMemoryRequest {
    /**
     * The CXL port name on the Memory Appliance
     * @type {string}
     * @memberof ComposeMemoryRequest
     */
    'Port'?: string;
    /**
     * A mebibyte equals 2**20 or 1,048,576 bytes.
     * @type {number}
     * @memberof ComposeMemoryRequest
     */
    'memorySizeMiB': number;
    /**
     * 
     * @type {Qos}
     * @memberof ComposeMemoryRequest
     */
    'QoS': Qos;
}


/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * The username credentials used to communicate with another service
     * @type {string}
     * @memberof Credentials
     */
    'username': string;
    /**
     * The password credentials used to communicate with another service
     * @type {string}
     * @memberof Credentials
     */
    'password': string;
    /**
     * The IP Address in dot notation of the service
     * @type {string}
     * @memberof Credentials
     */
    'ipAddress': string;
    /**
     * 
     * @type {number}
     * @memberof Credentials
     */
    'port': number;
    /**
     * Set to true if an insecure connection should be used
     * @type {boolean}
     * @memberof Credentials
     */
    'insecure'?: boolean;
    /**
     * Examples of http vs https
     * @type {string}
     * @memberof Credentials
     */
    'protocol'?: string;
    /**
     * Examples of backend
     * @type {string}
     * @memberof Credentials
     */
    'backend'?: string;
    /**
     * A user-defined string to uniquely identify an individual endpoint device.
     * @type {string}
     * @memberof Credentials
     */
    'customId'?: string;
}
/**
 * 
 * @export
 * @interface Host
 */
export interface Host {
    /**
     * The id uniquely identifies the resource within a resource collection. Since URIs are constructed with ids, must not contain RFC1738 unsafe characters.
     * @type {string}
     * @memberof Host
     */
    'id': string;
    /**
     * The IP Address in dot notation of the service
     * @type {string}
     * @memberof Host
     */
    'ipAddress': string;
    /**
     * 
     * @type {number}
     * @memberof Host
     */
    'port': number;
    /**
     * A response string
     * @type {string}
     * @memberof Host
     */
    'status'?: string;
    /**
     * 
     * @type {MemberItem}
     * @memberof Host
     */
    'ports'?: MemberItem;
    /**
     * 
     * @type {MemberItem}
     * @memberof Host
     */
    'memory-devices'?: MemberItem;
    /**
     * 
     * @type {MemberItem}
     * @memberof Host
     */
    'memory'?: MemberItem;
    /**
     * A mebibyte equals 2**20 or 1,048,576 bytes.
     * @type {number}
     * @memberof Host
     */
    'localMemoryMiB'?: number;
    /**
     * A mebibyte equals 2**20 or 1,048,576 bytes.
     * @type {number}
     * @memberof Host
     */
    'remoteMemoryMiB'?: number;
}
/**
 * 
 * @export
 * @interface MemberItem
 */
export interface MemberItem {
    /**
     * A full path to the resource with id as the last component
     * @type {string}
     * @memberof MemberItem
     */
    'uri': string;
}
/**
 * 
 * @export
 * @interface MemoryDeviceInformation
 */
export interface MemoryDeviceInformation {
    /**
     * The id of this resource
     * @type {string}
     * @memberof MemoryDeviceInformation
     */
    'id': string;
    /**
     * The type of the device
     * @type {string}
     * @memberof MemoryDeviceInformation
     */
    'deviceType'?: string;
    /**
     * A mebibyte equals 2**20 or 1,048,576 bytes.
     * @type {number}
     * @memberof MemoryDeviceInformation
     */
    'memorySizeMiB'?: number;
    /**
     * 
     * @type {MemoryDeviceInformationLinkStatus}
     * @memberof MemoryDeviceInformation
     */
    'linkStatus'?: MemoryDeviceInformationLinkStatus;
    /**
     * The state of the resource
     * @type {string}
     * @memberof MemoryDeviceInformation
     */
    'statusState'?: string;
}
/**
 * The speed and width about the link
 * @export
 * @interface MemoryDeviceInformationLinkStatus
 */
export interface MemoryDeviceInformationLinkStatus {
    /**
     * The current speed of this link
     * @type {number}
     * @memberof MemoryDeviceInformationLinkStatus
     */
    'currentSpeedGTps'?: number;
    /**
     * The max speed of this link
     * @type {number}
     * @memberof MemoryDeviceInformationLinkStatus
     */
    'maxSpeedGTps'?: number;
    /**
     * The current width of this link
     * @type {number}
     * @memberof MemoryDeviceInformationLinkStatus
     */
    'currentWidth'?: number;
    /**
     * The max width of this link
     * @type {number}
     * @memberof MemoryDeviceInformationLinkStatus
     */
    'maxWidth'?: number;
}
/**
 * 
 * @export
 * @interface MemoryRegion
 */
export interface MemoryRegion {
    /**
     * The id uniquely identifies the resource within a resource collection. Since URIs are constructed with ids, must not contain RFC1738 unsafe characters.
     * @type {string}
     * @memberof MemoryRegion
     */
    'id': string;
    /**
     * A response string
     * @type {string}
     * @memberof MemoryRegion
     */
    'status'?: string;
    /**
     * 
     * @type {MemoryType}
     * @memberof MemoryRegion
     */
    'type': MemoryType;
    /**
     * A mebibyte equals 2**20 or 1,048,576 bytes.
     * @type {number}
     * @memberof MemoryRegion
     */
    'sizeMiB': number;
    /**
     * Memory bandwidth in the unit of GigaBytes per second
     * @type {number}
     * @memberof MemoryRegion
     */
    'bandwidth'?: number;
    /**
     * Memory latency in the unit of nanosecond
     * @type {number}
     * @memberof MemoryRegion
     */
    'latency'?: number;
    /**
     * The id uniquely identifies the resource within a resource collection. Since URIs are constructed with ids, must not contain RFC1738 unsafe characters.
     * @type {string}
     * @memberof MemoryRegion
     */
    'memoryApplianceId'?: string;
    /**
     * The id uniquely identifies the resource within a resource collection. Since URIs are constructed with ids, must not contain RFC1738 unsafe characters.
     * @type {string}
     * @memberof MemoryRegion
     */
    'memoryBladeId'?: string;
    /**
     * The CXL port name on the Memory Appliance
     * @type {string}
     * @memberof MemoryRegion
     */
    'memoryAppliancePort'?: string;
    /**
     * The id uniquely identifies the resource within a resource collection. Since URIs are constructed with ids, must not contain RFC1738 unsafe characters.
     * @type {string}
     * @memberof MemoryRegion
     */
    'mappedHostId'?: string;
    /**
     * The id uniquely identifies the resource within a resource collection. Since URIs are constructed with ids, must not contain RFC1738 unsafe characters.
     * @type {string}
     * @memberof MemoryRegion
     */
    'mappedHostPort'?: string;
}


/**
 * 
 * @export
 * @interface MemoryResourceBlock
 */
export interface MemoryResourceBlock {
    /**
     * The id of this resource
     * @type {string}
     * @memberof MemoryResourceBlock
     */
    'id': string;
    /**
     * 
     * @type {MemoryResourceBlockCompositionStatus}
     * @memberof MemoryResourceBlock
     */
    'compositionStatus': MemoryResourceBlockCompositionStatus;
    /**
     * The number of compositions in which this resource block is currently participating
     * @type {number}
     * @memberof MemoryResourceBlock
     */
    'capacityMiB'?: number;
    /**
     * The number of compositions in which this resource block is currently participating
     * @type {number}
     * @memberof MemoryResourceBlock
     */
    'dataWidthBits'?: number;
    /**
     * The type of memory device
     * @type {string}
     * @memberof MemoryResourceBlock
     */
    'memoryType'?: string;
    /**
     * Type details of the memory device
     * @type {string}
     * @memberof MemoryResourceBlock
     */
    'memoryDeviceType'?: string;
    /**
     * The memory device manufacturer
     * @type {string}
     * @memberof MemoryResourceBlock
     */
    'manufacturer'?: string;
    /**
     * Operating speed of the memory device in MHz
     * @type {number}
     * @memberof MemoryResourceBlock
     */
    'operatingSpeedMhz'?: number;
    /**
     * The product part number of this device
     * @type {string}
     * @memberof MemoryResourceBlock
     */
    'partNumber'?: string;
    /**
     * The product serial number of this device
     * @type {string}
     * @memberof MemoryResourceBlock
     */
    'serialNumber'?: string;
    /**
     * Number of ranks available in the memory device
     * @type {number}
     * @memberof MemoryResourceBlock
     */
    'rankCount'?: number;
    /**
     * Id of the channel(dimm) associated with this resource
     * @type {number}
     * @memberof MemoryResourceBlock
     */
    'channelId': number;
    /**
     * Position index for this resource within the designated channel(dimm)
     * @type {number}
     * @memberof MemoryResourceBlock
     */
    'channelResourceIndex': number;
}
/**
 * 
 * @export
 * @interface MemoryResourceBlockCompositionStatus
 */
export interface MemoryResourceBlockCompositionStatus {
    /**
     * The current state of the resource block from a composition perspective
     * @type {string}
     * @memberof MemoryResourceBlockCompositionStatus
     */
    'compositionState': string;
    /**
     * The maximum number of compositions in which this resource block can participate simultaneously
     * @type {number}
     * @memberof MemoryResourceBlockCompositionStatus
     */
    'maxCompositions'?: number;
    /**
     * The number of compositions in which this resource block is currently participating
     * @type {number}
     * @memberof MemoryResourceBlockCompositionStatus
     */
    'numberOfCompositions'?: number;
}
/**
 * The type of constructed memory.
 * @export
 * @enum {string}
 */

export const MemoryType = {
    MemoryTypeUnknown: 'MemoryTypeUnknown',
    MemoryTypeRegion: 'MemoryTypeRegion',
    MemoryTypeLocal: 'MemoryTypeLocal',
    MemoryTypeCxl: 'MemoryTypeCXL'
} as const;

export type MemoryType = typeof MemoryType[keyof typeof MemoryType];


/**
 * 
 * @export
 * @interface PortInformation
 */
export interface PortInformation {
    /**
     * The id of this resource
     * @type {string}
     * @memberof PortInformation
     */
    'id': string;
    /**
     * The global CXL identifier
     * @type {string}
     * @memberof PortInformation
     */
    'gCxlId'?: string;
    /**
     * A full path to the resource with id as the last component
     * @type {string}
     * @memberof PortInformation
     */
    'linkedPortUri'?: string;
    /**
     * The protocol being sent over this port
     * @type {string}
     * @memberof PortInformation
     */
    'portProtocol'?: string;
    /**
     * The physical connection medium for this port
     * @type {string}
     * @memberof PortInformation
     */
    'portMedium'?: string;
    /**
     * The current speed of this port
     * @type {number}
     * @memberof PortInformation
     */
    'currentSpeedGbps'?: number;
    /**
     * The health of the resource
     * @type {string}
     * @memberof PortInformation
     */
    'statusHealth': string;
    /**
     * The state of the resource
     * @type {string}
     * @memberof PortInformation
     */
    'statusState': string;
    /**
     * The number of lanes, phys, or other physical transport links that this port contains
     * @type {number}
     * @memberof PortInformation
     */
    'width'?: number;
    /**
     * Status of the link, such as LinkUp or LinkDown
     * @type {string}
     * @memberof PortInformation
     */
    'linkStatus'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Qos = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4,
    NUMBER_8: 8
} as const;

export type Qos = typeof Qos[keyof typeof Qos];


/**
 * 
 * @export
 * @interface ServiceInformation
 */
export interface ServiceInformation {
    /**
     * The cfm-service version
     * @type {string}
     * @memberof ServiceInformation
     */
    'version': string;
    /**
     * 
     * @type {Array<ServiceResource>}
     * @memberof ServiceInformation
     */
    'resources': Array<ServiceResource>;
}
/**
 * 
 * @export
 * @interface ServiceResource
 */
export interface ServiceResource {
    /**
     * A full path to the resource with id as the last component
     * @type {string}
     * @memberof ServiceResource
     */
    'uri': string;
    /**
     * The service(s) available for the specified URI
     * @type {string}
     * @memberof ServiceResource
     */
    'methods': string;
    /**
     * The description of service(s) offered by the URI
     * @type {string}
     * @memberof ServiceResource
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface StatusMessage
 */
export interface StatusMessage {
    /**
     * The URI of the http request
     * @type {string}
     * @memberof StatusMessage
     */
    'uri': string;
    /**
     * Additional information provided to the client regarding this response
     * @type {string}
     * @memberof StatusMessage
     */
    'details': string;
    /**
     * 
     * @type {StatusMessageStatus}
     * @memberof StatusMessage
     */
    'status'?: StatusMessageStatus;
}
/**
 * 
 * @export
 * @interface StatusMessageStatus
 */
export interface StatusMessageStatus {
    /**
     * A unique status code value
     * @type {number}
     * @memberof StatusMessageStatus
     */
    'code': number;
    /**
     * A description of the status code
     * @type {string}
     * @memberof StatusMessageStatus
     */
    'message': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove a memory appliance by id from cfm-service management.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliancesDeleteById: async (applianceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('appliancesDeleteById', 'applianceId', applianceId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of all managed memory appliances. Collection may be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliancesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cfm/v1/appliances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a single memory appliance. {applianceId} has to match the id of the appliance.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliancesGetById: async (applianceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('appliancesGetById', 'applianceId', applianceId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new memory appliance and optional credentials to be managed by cfm-service.
         * @param {Credentials} [credentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliancesPost: async (credentials?: Credentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cfm/v1/appliances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a memory region to a CXL port or Unassign a memory region from a CXL port
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {AssignMemoryRequest} assignMemoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesAssignMemoryById: async (applianceId: string, bladeId: string, memoryId: string, assignMemoryRequest: AssignMemoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesAssignMemoryById', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesAssignMemoryById', 'bladeId', bladeId)
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists('bladesAssignMemoryById', 'memoryId', memoryId)
            // verify required parameter 'assignMemoryRequest' is not null or undefined
            assertParamExists('bladesAssignMemoryById', 'assignMemoryRequest', assignMemoryRequest)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/memory/{memoryId}`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignMemoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allocate a new memory region from a Memory Blade and possibly assign it to a CXL Host.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {ComposeMemoryRequest} composeMemoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesComposeMemory: async (applianceId: string, bladeId: string, composeMemoryRequest: ComposeMemoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesComposeMemory', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesComposeMemory', 'bladeId', bladeId)
            // verify required parameter 'composeMemoryRequest' is not null or undefined
            assertParamExists('bladesComposeMemory', 'composeMemoryRequest', composeMemoryRequest)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/memory`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(composeMemoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allocate a new memory region from a Memory Blade with the supplied resource blocks and possibly assign it to a CXL Host.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {ComposeMemoryByResourceRequest} composeMemoryByResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesComposeMemoryByResource: async (applianceId: string, bladeId: string, composeMemoryByResourceRequest: ComposeMemoryByResourceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesComposeMemoryByResource', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesComposeMemoryByResource', 'bladeId', bladeId)
            // verify required parameter 'composeMemoryByResourceRequest' is not null or undefined
            assertParamExists('bladesComposeMemoryByResource', 'composeMemoryByResourceRequest', composeMemoryByResourceRequest)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/memory`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(composeMemoryByResourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a memory blade by id from cfm-service management.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesDeleteById: async (applianceId: string, bladeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesDeleteById', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesDeleteById', 'bladeId', bladeId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Free a memory region by id
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesFreeMemoryById: async (applianceId: string, bladeId: string, memoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesFreeMemoryById', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesFreeMemoryById', 'bladeId', bladeId)
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists('bladesFreeMemoryById', 'memoryId', memoryId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/memory/{memoryId}`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of all managed blades under a memory appliance. Collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGet: async (applianceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesGet', 'applianceId', applianceId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a single memory blade. {bladeId} has to match the id of the blade.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetById: async (applianceId: string, bladeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesGetById', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesGetById', 'bladeId', bladeId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of memory regions. The collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetMemory: async (applianceId: string, bladeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesGetMemory', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesGetMemory', 'bladeId', bladeId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/memory`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a single memory region.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetMemoryById: async (applianceId: string, bladeId: string, memoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesGetMemoryById', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesGetMemoryById', 'bladeId', bladeId)
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists('bladesGetMemoryById', 'memoryId', memoryId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/memory/{memoryId}`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a single port.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} portId A unique identifier for a Port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetPortById: async (applianceId: string, bladeId: string, portId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesGetPortById', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesGetPortById', 'bladeId', bladeId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('bladesGetPortById', 'portId', portId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/ports/{portId}`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)))
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of memory appliance ports. The collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetPorts: async (applianceId: string, bladeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesGetPorts', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesGetPorts', 'bladeId', bladeId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/ports`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a single memory resource block.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} resourceId A unique identifier for a Memory Resource Block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetResourceById: async (applianceId: string, bladeId: string, resourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesGetResourceById', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesGetResourceById', 'bladeId', bladeId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('bladesGetResourceById', 'resourceId', resourceId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/resources/{resourceId}`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of memory blade resources. The collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetResources: async (applianceId: string, bladeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesGetResources', 'applianceId', applianceId)
            // verify required parameter 'bladeId' is not null or undefined
            assertParamExists('bladesGetResources', 'bladeId', bladeId)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades/{bladeId}/resources`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)))
                .replace(`{${"bladeId"}}`, encodeURIComponent(String(bladeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new blade under a memory appliance and credentials to be managed by cfm-service.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {Credentials} credentials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesPost: async (applianceId: string, credentials: Credentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applianceId' is not null or undefined
            assertParamExists('bladesPost', 'applianceId', applianceId)
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('bladesPost', 'credentials', credentials)
            const localVarPath = `/cfm/v1/appliances/{applianceId}/blades`
                .replace(`{${"applianceId"}}`, encodeURIComponent(String(applianceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfmGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cfm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfmV1Get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cfm/v1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of memory regions on CXL host.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostGetMemory: async (hostId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostGetMemory', 'hostId', hostId)
            const localVarPath = `/cfm/v1/hosts/{hostId}/memory`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inform the CXL Host about a new memory region from a memory appliance to a CXL host.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {ComposeMemoryRequest} composeMemoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsComposeMemory: async (hostId: string, composeMemoryRequest: ComposeMemoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostsComposeMemory', 'hostId', hostId)
            // verify required parameter 'composeMemoryRequest' is not null or undefined
            assertParamExists('hostsComposeMemory', 'composeMemoryRequest', composeMemoryRequest)
            const localVarPath = `/cfm/v1/hosts/{hostId}/memory`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(composeMemoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a CXL Host by id from cfm-service management.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsDeleteById: async (hostId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostsDeleteById', 'hostId', hostId)
            const localVarPath = `/cfm/v1/hosts/{hostId}`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Free a memory region by id
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsFreeMemoryById: async (hostId: string, memoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostsFreeMemoryById', 'hostId', hostId)
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists('hostsFreeMemoryById', 'memoryId', memoryId)
            const localVarPath = `/cfm/v1/hosts/{hostId}/memory/{memoryId}`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current state of CXL hosts including allocated memory regions.
         * @summary Get CXL Host information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cfm/v1/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information for a single CXL Host.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetById: async (hostId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostsGetById', 'hostId', hostId)
            const localVarPath = `/cfm/v1/hosts/{hostId}`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a single memory region.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetMemoryById: async (hostId: string, memoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostsGetMemoryById', 'hostId', hostId)
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists('hostsGetMemoryById', 'memoryId', memoryId)
            const localVarPath = `/cfm/v1/hosts/{hostId}/memory/{memoryId}`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a single memory device ( CXL logical device ).
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} memoryDeviceId A unique identifier for a memory device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetMemoryDeviceById: async (hostId: string, memoryDeviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostsGetMemoryDeviceById', 'hostId', hostId)
            // verify required parameter 'memoryDeviceId' is not null or undefined
            assertParamExists('hostsGetMemoryDeviceById', 'memoryDeviceId', memoryDeviceId)
            const localVarPath = `/cfm/v1/hosts/{hostId}/memory-devices/{memoryDeviceId}`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)))
                .replace(`{${"memoryDeviceId"}}`, encodeURIComponent(String(memoryDeviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of CXL host memory devices ( CXL logical devices ).
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetMemoryDevices: async (hostId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostsGetMemoryDevices', 'hostId', hostId)
            const localVarPath = `/cfm/v1/hosts/{hostId}/memory-devices`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a single port.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} portId A unique identifier for a Port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetPortById: async (hostId: string, portId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostsGetPortById', 'hostId', hostId)
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('hostsGetPortById', 'portId', portId)
            const localVarPath = `/cfm/v1/hosts/{hostId}/ports/{portId}`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)))
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of CXL host ports.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetPorts: async (hostId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostId' is not null or undefined
            assertParamExists('hostsGetPorts', 'hostId', hostId)
            const localVarPath = `/cfm/v1/hosts/{hostId}/ports`
                .replace(`{${"hostId"}}`, encodeURIComponent(String(hostId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new CXL host and credentials to be managed by the cfm-service.
         * @summary Add a CXL host to be managed by CFM.
         * @param {Credentials} credentials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsPost: async (credentials: Credentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('hostsPost', 'credentials', credentials)
            const localVarPath = `/cfm/v1/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove a memory appliance by id from cfm-service management.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appliancesDeleteById(applianceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appliance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appliancesDeleteById(applianceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of all managed memory appliances. Collection may be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appliancesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appliancesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for a single memory appliance. {applianceId} has to match the id of the appliance.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appliancesGetById(applianceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appliance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appliancesGetById(applianceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new memory appliance and optional credentials to be managed by cfm-service.
         * @param {Credentials} [credentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appliancesPost(credentials?: Credentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appliance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appliancesPost(credentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assign a memory region to a CXL port or Unassign a memory region from a CXL port
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {AssignMemoryRequest} assignMemoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesAssignMemoryById(applianceId: string, bladeId: string, memoryId: string, assignMemoryRequest: AssignMemoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesAssignMemoryById(applianceId, bladeId, memoryId, assignMemoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allocate a new memory region from a Memory Blade and possibly assign it to a CXL Host.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {ComposeMemoryRequest} composeMemoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesComposeMemory(applianceId: string, bladeId: string, composeMemoryRequest: ComposeMemoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesComposeMemory(applianceId, bladeId, composeMemoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allocate a new memory region from a Memory Blade with the supplied resource blocks and possibly assign it to a CXL Host.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {ComposeMemoryByResourceRequest} composeMemoryByResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesComposeMemoryByResource(applianceId: string, bladeId: string, composeMemoryByResourceRequest: ComposeMemoryByResourceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesComposeMemoryByResource(applianceId, bladeId, composeMemoryByResourceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a memory blade by id from cfm-service management.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesDeleteById(applianceId: string, bladeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesDeleteById(applianceId, bladeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Free a memory region by id
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesFreeMemoryById(applianceId: string, bladeId: string, memoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesFreeMemoryById(applianceId, bladeId, memoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of all managed blades under a memory appliance. Collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesGet(applianceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesGet(applianceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for a single memory blade. {bladeId} has to match the id of the blade.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesGetById(applianceId: string, bladeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesGetById(applianceId, bladeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of memory regions. The collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesGetMemory(applianceId: string, bladeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesGetMemory(applianceId, bladeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for a single memory region.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesGetMemoryById(applianceId: string, bladeId: string, memoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesGetMemoryById(applianceId, bladeId, memoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for a single port.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} portId A unique identifier for a Port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesGetPortById(applianceId: string, bladeId: string, portId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesGetPortById(applianceId, bladeId, portId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of memory appliance ports. The collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesGetPorts(applianceId: string, bladeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesGetPorts(applianceId, bladeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for a single memory resource block.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} resourceId A unique identifier for a Memory Resource Block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesGetResourceById(applianceId: string, bladeId: string, resourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryResourceBlock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesGetResourceById(applianceId, bladeId, resourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of memory blade resources. The collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesGetResources(applianceId: string, bladeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesGetResources(applianceId, bladeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new blade under a memory appliance and credentials to be managed by cfm-service.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {Credentials} credentials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bladesPost(applianceId: string, credentials: Credentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bladesPost(applianceId, credentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cfmGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cfmGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cfmV1Get(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cfmV1Get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of memory regions on CXL host.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostGetMemory(hostId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostGetMemory(hostId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inform the CXL Host about a new memory region from a memory appliance to a CXL host.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {ComposeMemoryRequest} composeMemoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsComposeMemory(hostId: string, composeMemoryRequest: ComposeMemoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsComposeMemory(hostId, composeMemoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a CXL Host by id from cfm-service management.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsDeleteById(hostId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsDeleteById(hostId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Free a memory region by id
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsFreeMemoryById(hostId: string, memoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsFreeMemoryById(hostId, memoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the current state of CXL hosts including allocated memory regions.
         * @summary Get CXL Host information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information for a single CXL Host.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsGetById(hostId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsGetById(hostId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for a single memory region.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsGetMemoryById(hostId: string, memoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryRegion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsGetMemoryById(hostId, memoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for a single memory device ( CXL logical device ).
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} memoryDeviceId A unique identifier for a memory device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsGetMemoryDeviceById(hostId: string, memoryDeviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryDeviceInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsGetMemoryDeviceById(hostId, memoryDeviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of CXL host memory devices ( CXL logical devices ).
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsGetMemoryDevices(hostId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsGetMemoryDevices(hostId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information for a single port.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} portId A unique identifier for a Port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsGetPortById(hostId: string, portId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsGetPortById(hostId, portId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of CXL host ports.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsGetPorts(hostId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Collection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsGetPorts(hostId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new CXL host and credentials to be managed by the cfm-service.
         * @summary Add a CXL host to be managed by CFM.
         * @param {Credentials} credentials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostsPost(credentials: Credentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostsPost(credentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Remove a memory appliance by id from cfm-service management.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliancesDeleteById(applianceId: string, options?: any): AxiosPromise<Appliance> {
            return localVarFp.appliancesDeleteById(applianceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of all managed memory appliances. Collection may be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliancesGet(options?: any): AxiosPromise<Collection> {
            return localVarFp.appliancesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a single memory appliance. {applianceId} has to match the id of the appliance.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliancesGetById(applianceId: string, options?: any): AxiosPromise<Appliance> {
            return localVarFp.appliancesGetById(applianceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new memory appliance and optional credentials to be managed by cfm-service.
         * @param {Credentials} [credentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliancesPost(credentials?: Credentials, options?: any): AxiosPromise<Appliance> {
            return localVarFp.appliancesPost(credentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a memory region to a CXL port or Unassign a memory region from a CXL port
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {AssignMemoryRequest} assignMemoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesAssignMemoryById(applianceId: string, bladeId: string, memoryId: string, assignMemoryRequest: AssignMemoryRequest, options?: any): AxiosPromise<MemoryRegion> {
            return localVarFp.bladesAssignMemoryById(applianceId, bladeId, memoryId, assignMemoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allocate a new memory region from a Memory Blade and possibly assign it to a CXL Host.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {ComposeMemoryRequest} composeMemoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesComposeMemory(applianceId: string, bladeId: string, composeMemoryRequest: ComposeMemoryRequest, options?: any): AxiosPromise<MemoryRegion> {
            return localVarFp.bladesComposeMemory(applianceId, bladeId, composeMemoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allocate a new memory region from a Memory Blade with the supplied resource blocks and possibly assign it to a CXL Host.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {ComposeMemoryByResourceRequest} composeMemoryByResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesComposeMemoryByResource(applianceId: string, bladeId: string, composeMemoryByResourceRequest: ComposeMemoryByResourceRequest, options?: any): AxiosPromise<MemoryRegion> {
            return localVarFp.bladesComposeMemoryByResource(applianceId, bladeId, composeMemoryByResourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a memory blade by id from cfm-service management.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesDeleteById(applianceId: string, bladeId: string, options?: any): AxiosPromise<Blade> {
            return localVarFp.bladesDeleteById(applianceId, bladeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Free a memory region by id
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesFreeMemoryById(applianceId: string, bladeId: string, memoryId: string, options?: any): AxiosPromise<MemoryRegion> {
            return localVarFp.bladesFreeMemoryById(applianceId, bladeId, memoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of all managed blades under a memory appliance. Collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGet(applianceId: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.bladesGet(applianceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a single memory blade. {bladeId} has to match the id of the blade.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetById(applianceId: string, bladeId: string, options?: any): AxiosPromise<Blade> {
            return localVarFp.bladesGetById(applianceId, bladeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of memory regions. The collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetMemory(applianceId: string, bladeId: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.bladesGetMemory(applianceId, bladeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a single memory region.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetMemoryById(applianceId: string, bladeId: string, memoryId: string, options?: any): AxiosPromise<MemoryRegion> {
            return localVarFp.bladesGetMemoryById(applianceId, bladeId, memoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a single port.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} portId A unique identifier for a Port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetPortById(applianceId: string, bladeId: string, portId: string, options?: any): AxiosPromise<PortInformation> {
            return localVarFp.bladesGetPortById(applianceId, bladeId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of memory appliance ports. The collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetPorts(applianceId: string, bladeId: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.bladesGetPorts(applianceId, bladeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a single memory resource block.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {string} resourceId A unique identifier for a Memory Resource Block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetResourceById(applianceId: string, bladeId: string, resourceId: string, options?: any): AxiosPromise<MemoryResourceBlock> {
            return localVarFp.bladesGetResourceById(applianceId, bladeId, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of memory blade resources. The collection may be empty.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {string} bladeId A unique identifier for a Memory Blade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesGetResources(applianceId: string, bladeId: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.bladesGetResources(applianceId, bladeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new blade under a memory appliance and credentials to be managed by cfm-service.
         * @param {string} applianceId A unique identifier for a Memory Appliance
         * @param {Credentials} credentials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bladesPost(applianceId: string, credentials: Credentials, options?: any): AxiosPromise<Blade> {
            return localVarFp.bladesPost(applianceId, credentials, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfmGet(options?: any): AxiosPromise<string> {
            return localVarFp.cfmGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfmV1Get(options?: any): AxiosPromise<ServiceInformation> {
            return localVarFp.cfmV1Get(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of memory regions on CXL host.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostGetMemory(hostId: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.hostGetMemory(hostId, options).then((request) => request(axios, basePath));
        },
        /**
         * Inform the CXL Host about a new memory region from a memory appliance to a CXL host.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {ComposeMemoryRequest} composeMemoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsComposeMemory(hostId: string, composeMemoryRequest: ComposeMemoryRequest, options?: any): AxiosPromise<MemoryRegion> {
            return localVarFp.hostsComposeMemory(hostId, composeMemoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a CXL Host by id from cfm-service management.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsDeleteById(hostId: string, options?: any): AxiosPromise<Host> {
            return localVarFp.hostsDeleteById(hostId, options).then((request) => request(axios, basePath));
        },
        /**
         * Free a memory region by id
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsFreeMemoryById(hostId: string, memoryId: string, options?: any): AxiosPromise<MemoryRegion> {
            return localVarFp.hostsFreeMemoryById(hostId, memoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the current state of CXL hosts including allocated memory regions.
         * @summary Get CXL Host information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGet(options?: any): AxiosPromise<Collection> {
            return localVarFp.hostsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information for a single CXL Host.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetById(hostId: string, options?: any): AxiosPromise<Host> {
            return localVarFp.hostsGetById(hostId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a single memory region.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} memoryId A unique identifier for a Memory Region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetMemoryById(hostId: string, memoryId: string, options?: any): AxiosPromise<MemoryRegion> {
            return localVarFp.hostsGetMemoryById(hostId, memoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a single memory device ( CXL logical device ).
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} memoryDeviceId A unique identifier for a memory device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetMemoryDeviceById(hostId: string, memoryDeviceId: string, options?: any): AxiosPromise<MemoryDeviceInformation> {
            return localVarFp.hostsGetMemoryDeviceById(hostId, memoryDeviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of CXL host memory devices ( CXL logical devices ).
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetMemoryDevices(hostId: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.hostsGetMemoryDevices(hostId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a single port.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {string} portId A unique identifier for a Port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetPortById(hostId: string, portId: string, options?: any): AxiosPromise<PortInformation> {
            return localVarFp.hostsGetPortById(hostId, portId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of CXL host ports.
         * @param {string} hostId A unique identifier for a CXL Host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsGetPorts(hostId: string, options?: any): AxiosPromise<Collection> {
            return localVarFp.hostsGetPorts(hostId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new CXL host and credentials to be managed by the cfm-service.
         * @summary Add a CXL host to be managed by CFM.
         * @param {Credentials} credentials 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostsPost(credentials: Credentials, options?: any): AxiosPromise<Host> {
            return localVarFp.hostsPost(credentials, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): AxiosPromise<string> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Remove a memory appliance by id from cfm-service management.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appliancesDeleteById(applianceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appliancesDeleteById(applianceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of all managed memory appliances. Collection may be empty.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appliancesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appliancesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a single memory appliance. {applianceId} has to match the id of the appliance.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appliancesGetById(applianceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appliancesGetById(applianceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new memory appliance and optional credentials to be managed by cfm-service.
     * @param {Credentials} [credentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appliancesPost(credentials?: Credentials, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appliancesPost(credentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a memory region to a CXL port or Unassign a memory region from a CXL port
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {string} memoryId A unique identifier for a Memory Region
     * @param {AssignMemoryRequest} assignMemoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesAssignMemoryById(applianceId: string, bladeId: string, memoryId: string, assignMemoryRequest: AssignMemoryRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesAssignMemoryById(applianceId, bladeId, memoryId, assignMemoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allocate a new memory region from a Memory Blade and possibly assign it to a CXL Host.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {ComposeMemoryRequest} composeMemoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesComposeMemory(applianceId: string, bladeId: string, composeMemoryRequest: ComposeMemoryRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesComposeMemory(applianceId, bladeId, composeMemoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allocate a new memory region from a Memory Blade with the supplied resource blocks and possibly assign it to a CXL Host.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {ComposeMemoryByResourceRequest} composeMemoryByResourceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesComposeMemoryByResource(applianceId: string, bladeId: string, composeMemoryByResourceRequest: ComposeMemoryByResourceRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesComposeMemoryByResource(applianceId, bladeId, composeMemoryByResourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a memory blade by id from cfm-service management.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesDeleteById(applianceId: string, bladeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesDeleteById(applianceId, bladeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Free a memory region by id
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {string} memoryId A unique identifier for a Memory Region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesFreeMemoryById(applianceId: string, bladeId: string, memoryId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesFreeMemoryById(applianceId, bladeId, memoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of all managed blades under a memory appliance. Collection may be empty.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesGet(applianceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesGet(applianceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a single memory blade. {bladeId} has to match the id of the blade.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesGetById(applianceId: string, bladeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesGetById(applianceId, bladeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of memory regions. The collection may be empty.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesGetMemory(applianceId: string, bladeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesGetMemory(applianceId, bladeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a single memory region.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {string} memoryId A unique identifier for a Memory Region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesGetMemoryById(applianceId: string, bladeId: string, memoryId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesGetMemoryById(applianceId, bladeId, memoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a single port.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {string} portId A unique identifier for a Port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesGetPortById(applianceId: string, bladeId: string, portId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesGetPortById(applianceId, bladeId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of memory appliance ports. The collection may be empty.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesGetPorts(applianceId: string, bladeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesGetPorts(applianceId, bladeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a single memory resource block.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {string} resourceId A unique identifier for a Memory Resource Block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesGetResourceById(applianceId: string, bladeId: string, resourceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesGetResourceById(applianceId, bladeId, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of memory blade resources. The collection may be empty.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {string} bladeId A unique identifier for a Memory Blade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesGetResources(applianceId: string, bladeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesGetResources(applianceId, bladeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new blade under a memory appliance and credentials to be managed by cfm-service.
     * @param {string} applianceId A unique identifier for a Memory Appliance
     * @param {Credentials} credentials 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public bladesPost(applianceId: string, credentials: Credentials, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).bladesPost(applianceId, credentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cfmGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cfmGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cfmV1Get(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cfmV1Get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of memory regions on CXL host.
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostGetMemory(hostId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostGetMemory(hostId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inform the CXL Host about a new memory region from a memory appliance to a CXL host.
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {ComposeMemoryRequest} composeMemoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsComposeMemory(hostId: string, composeMemoryRequest: ComposeMemoryRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsComposeMemory(hostId, composeMemoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a CXL Host by id from cfm-service management.
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsDeleteById(hostId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsDeleteById(hostId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Free a memory region by id
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {string} memoryId A unique identifier for a Memory Region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsFreeMemoryById(hostId: string, memoryId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsFreeMemoryById(hostId, memoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the current state of CXL hosts including allocated memory regions.
     * @summary Get CXL Host information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information for a single CXL Host.
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsGetById(hostId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsGetById(hostId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a single memory region.
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {string} memoryId A unique identifier for a Memory Region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsGetMemoryById(hostId: string, memoryId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsGetMemoryById(hostId, memoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a single memory device ( CXL logical device ).
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {string} memoryDeviceId A unique identifier for a memory device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsGetMemoryDeviceById(hostId: string, memoryDeviceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsGetMemoryDeviceById(hostId, memoryDeviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of CXL host memory devices ( CXL logical devices ).
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsGetMemoryDevices(hostId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsGetMemoryDevices(hostId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a single port.
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {string} portId A unique identifier for a Port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsGetPortById(hostId: string, portId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsGetPortById(hostId, portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of CXL host ports.
     * @param {string} hostId A unique identifier for a CXL Host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsGetPorts(hostId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsGetPorts(hostId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new CXL host and credentials to be managed by the cfm-service.
     * @summary Add a CXL host to be managed by CFM.
     * @param {Credentials} credentials 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostsPost(credentials: Credentials, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).hostsPost(credentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



